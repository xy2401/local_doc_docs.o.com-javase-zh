<html lang="en-US" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>从结果集中检索和修改值（Java™教程&gt; JDBC（TM）数据库访问&gt; JDBC基础知识）</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
     <meta name="description" content="This JDBC Java tutorial describes how to use JDBC API to create, insert into, update, and query tables. You will also learn how to use simple and prepared statements, stored procedures and perform transactions"></meta>
     <meta name="keywords" content="java programming, learn java, java sample code, jdbc, prepared statement, result set"></meta>
        
<style type="text/css">body {
  margin-left: 10px;
  margin-right: 10px;
  line-height: 1.5;
  FONT-FAMILY: Arial,Helvetica,sans-serif;
  font-size: 0.8em;
}
a:link {
  text-decoration: none;
  color: #09569d;
}
a:visited {
  text-decoration: none;
  color: #3a87cf;
}
a:hover {
  text-decoration: underline;
}
code {
  font-family: Monaco,Courier,"Courier New";
}
.header-container {
  background-color: #fff;
  border-bottom: 1px solid #c1cfda;
  -webkit-box-shadow: 0 2px 2px rgba(117,163,231,0.1);
  box-shadow: 0 2px 2px rgba(117,163,231,0.1);
}
.bookwrapper {
  width: auto;
  margin: auto;
}
.clearfix {
}
.clearfloat {
  clear: both;
  overflow: auto;
  height: 0px;
  font-size: 1px;
  line-height: 0px;
}
#brandProdName {
  width: auto;
  height: auto;
}
#logocover {
  display: block;
  background: transparent url('../../images/oracle-java-logo.png') 0px 0px no-repeat;
  height: 50px;
  width: 229px;
  float: left;
}
#productName {
  font-size: 16px;
  position: relative;
  top: 19px;
  padding-left: 3px;
  color: #457798;
  white-space: nowrap;
  width: 340px;
}
.FigureCaption {
  font-family: sans-serif;
  text-align: center;
}
#TopBar_bl {
  width: 100%;
  height: 60px;
}
#TopBar_br {
  width: 100%;
  height: 60px;
}
#TopBar_tl {
  margin-left: -110px;
  margin-right: -100px;
  align: left;
  height: 60px;
}
#TopBar_tr {
  width: 100%;
  height: 60px;
}
#TopBar {
  min-width: 700px;
  padding: 25px 100px 10px;
  margin-bottom: 25px;
  clear: both;
  border-bottom: 1px solid #d2dde5;
  border-radius: 3px;
  background: #efefef;
  /* Old browsers */
  /* IE9 SVG, needs conditional override of 'filter' to 'none' */
  
  background: -moz-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* FF3.6+ */
  background: -webkit-gradient(linear,left top,left bottom,color-stop(0%,#ffffff),color-stop(100%,#e2eff9));
  /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* Opera 11.10+ */
  background: -ms-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* IE10+ */
  background: linear-gradient(to bottom,#ffffff 0%,#e2eff9 100%);
  /* W3C */
  /* IE6-8 */
}
#TopBar_left {
  line-height: 14px;
  position: absolute;
  padding-top: 30px;
  padding-right: 30px;
  padding-left: 30px;
  text-align: left;
  font: 13px/20px Arial,Helvetica,sans-serif;
  font-weight: bold;
  font-size: 20px;
  color: #333;
}
#TopBar_right {
  line-height: 12px;
  float: right;
  padding-top: 10px;
  padding-right: 30px;
  text-align: left;
}
@media print {
  #BreadCrumbs, #Download {
    display: none;
  }
}
@media print {
  #TopBar_right {
    display: none;
  }
}
#TopBar_right a {
  font-size: 10px;
  margin: 3px;
  padding: 0;
}
#BreadCrumbs {
  padding: 15px 5px 0.5em 0;
  font-family: sans-serif;
  float: right;
}
#BreadCrumbs a {
  color: #09569d;
}
#BreadCrumbs a:visited, #BreadCrumbs a:link {
  text-decoration: none;
}
#BreadCrumbs a:hover, #BreadCrumbs a:active {
  text-decoration: underline;
}
#PageTitle {
  margin: 0 5px 0.5em 0;
  color: #f90000;
}
#PageContent {
  margin: 0 5px 0 20px;
}
.LeftBar_shown {
  width: 13em;
  float: left;
}
@media print {
  .LeftBar_shown {
    display: none;
  }
}
.LeftBar_hidden {
  display: none;
}
#Footer {
  padding-top: 10px;
  padding-left: 10px;
  margin-right: 10px;
}
.footertext {
  font-size: 10px;
  font-family: sans-serif;
  margin-top: 1px;
}
.NavBit {
  padding: 15px 5px 0.5em 0;
  font-family: sans-serif;
}
@media print {
  .NavBit {
    display: none;
  }
}
#TagNotes {
  text-align: right;
}
@media print {
  #TagNotes a:visited, #TagNotes a:link {
    color: #35556b;
    text-decoration: none;
  }
}
#Contents a, .NavBit a, #TagNotes a {
  color: #09569d;
}
#TagNotes a:visited, #TagNotes a:link, #Contents a:visited, #Contents a:link, .NavBit a:visited, .NavBit a:link {
  text-decoration: none;
}
#TagNotes a:hover, #TagNotes a:active, #Contents a:hover, #Contents a:active, .NavBit a:hover, .NavBit a:active {
  text-decoration: underline;
}
#Contents {
  float: left;
  font-family: sans-serif;
}
@media print {
  #Contents {
    display: none;
  }
}
@media screen {
  div.PrintHeaders {
    display: none;
  }
}
.linkLESSON, .nolinkLESSON {
  margin-left: 0.5em;
  text-indent: -0.5em;
}
.linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS {
  margin-left: 1.5em;
  text-indent: -0.5em;
}
.linkBHEAD, .nolinkBHEAD {
  margin-left: 2.5em;
  text-indent: -0.5em;
}
.linkCHEAD, .nolinkCHEAD {
  margin-left: 3.5em;
  text-indent: -0.5em;
}
.nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD, .nolinkQUESTIONS {
  font-weight: bold;
  color: #333;
}
.MainFlow_indented {
  margin-right: 10px;
  margin-left: 15em;
  margin-bottom: 2em;
}
.MainFlow_wide {
  margin-right: 10px;
  margin-left: 10px;
  margin-bottom: 2em;
}
@media print {
  .MainFlow_indented, .MainFlow_wide {
    padding-top: 0;
    margin-top: 10px;
    margin-right: 10px;
    margin-left: 0;
  }
}
h1, h2, h3, h4, h5 {
  color: #333;
}
h1 {
  font-weight: bold;
  font-size: 20px;
}
h2 {
  font-weight: bold;
  font-size: 17px;
}
h3 {
  font-weight: bold;
  font-size: 14px;
}
h4 {
  font-size: 15px;
}
h5 {
  font-size: 12px;
}
#ToggleLeft {
  display: none;
}
.note {
  margin: 0 30px 0px 30px;
}
.codeblock {
  margin: 0 30px 0px 30px;
  font-size: 12px;
  font-family: Monaco,Courier,"Courier New";
}
.tocli {
  list-style-type: none;
}
.betadraft {
  color: red;
}
</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body dir="ltr" onload="load()">
    <noscript>启用了JavaScript的浏览器需要此页面正常运行。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文档</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            --> <a href="javascript:void(0);" id="ToggleLeft">隐藏TOC</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkLESSON"><a href="index.html">JDBC基础知识</a></div>
<div class="linkAHEAD"><a href="gettingstarted.html">入门</a></div>
<div class="linkAHEAD"><a href="processingsqlstatements.html">使用JDBC处理SQL语句</a></div>
<div class="linkAHEAD"><a href="connecting.html">建立连接</a></div>
<div class="linkAHEAD"><a href="sqldatasources.html">连接数据源对象</a></div>
<div class="linkAHEAD"><a href="sqlexception.html">处理SQLExceptions</a></div>
<div class="linkAHEAD"><a href="tables.html">设置表</a></div>
<div class="nolinkAHEAD">从结果集中检索和修改值</div>
<div class="linkAHEAD"><a href="prepared.html">使用准备好的陈述</a></div>
<div class="linkAHEAD"><a href="transactions.html">使用交易</a></div>
<div class="linkAHEAD"><a href="rowset.html">使用RowSet对象</a></div>
<div class="linkAHEAD"><a href="jdbcrowset.html">使用JdbcRowSet对象</a></div>
<div class="linkAHEAD"><a href="cachedrowset.html">使用CachedRowSetObjects</a></div>
<div class="linkAHEAD"><a href="joinrowset.html">使用JoinRowSet对象</a></div>
<div class="linkAHEAD"><a href="filteredrowset.html">使用FilteredRowSet对象</a></div>
<div class="linkAHEAD"><a href="webrowset.html">使用WebRowSet对象</a></div>
<div class="linkAHEAD"><a href="sqltypes.html">使用高级数据类型</a></div>
<div class="linkAHEAD"><a href="blob.html">使用大对象</a></div>
<div class="linkAHEAD"><a href="sqlxml.html">使用SQLXML对象</a></div>
<div class="linkAHEAD"><a href="array.html">使用数组对象</a></div>
<div class="linkAHEAD"><a href="distinct.html">使用DISTINCT数据类型</a></div>
<div class="linkAHEAD"><a href="sqlstructured.html">使用结构化对象</a></div>
<div class="linkAHEAD"><a href="sqlcustommapping.html">使用自定义类型映射</a></div>
<div class="linkAHEAD"><a href="sqldatalink.html">使用数据链接对象</a></div>
<div class="linkAHEAD"><a href="sqlrowid.html">使用RowId对象</a></div>
<div class="linkAHEAD"><a href="storedprocedures.html">使用存储过程</a></div>
<div class="linkAHEAD"><a href="jdbcswing.html">将JDBC与GUI API结合使用</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>Trail：</b> JDBC（TM）数据库访问<br><b>课程：</b> JDBC基础知识</div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">主页</a> &gt; <a href="../index.html" target="_top">JDBC（TM）数据库访问</a> &gt; <a href="index.html" target="_top">JDBC基础知识</a>
            </div>
            <div class="NavBit">
                <a href="tables.html" target="_top">«上一页</a> • <a href="../TOC.html" target="_top">小道</a> • <a href="prepared.html" target="_top">下一页»</a>
            </div>
            <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。本页中描述的示例和实践未利用后续版本中引入的改进。</p></div>
            <div id="PageTitle"><h1>从结果集中检索和修改值</h1></div>
            <div id="PageContent">

<p>以下方法， <code><a href="gettingstarted.html">CoffeesTable.viewTable</a></code>输出<code>COFFEES</code>表的内容，并演示<code>ResultSet</code>对象和游标的使用：</p>
<div class="codeblock"><pre>public static void viewTable（Connection con，String dbName）throws SQLException {Statement stmt = null;字符串查询=“从”+ dbName +“选择COF_NAME，SUP_ID，PRICE，”+“SALES，TOTAL”+“。COFFEES“; try {stmt = con.createStatement（）; ResultSet rs = stmt.executeQuery（query）; while（rs.next（））{String coffeeName = rs.getString（”COF_NAME“）; int supplierID = rs.getInt （“SUP_ID”）;浮动价格= rs.getFloat（“PRICE”）; int sales = rs.getInt（“SALES”）; int total = rs.getInt（“TOTAL”）; System.out.println（coffeeName + “\ t”+ supplierID +“\ t”+价格+“\ t”+销售额+“\ t”+总数）;}} catch（SQLException e）{JDBCTutorialUtilities.printSQLException（e）;} finally {if（stmt） ！= null）{stmt.close（）; }}}</pre></div>
<p><code>ResultSet</code>对象是表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。例如， <code><a href="gettingstarted.html">CoffeeTables.viewTable</a></code>方法在通过<code>Statement</code>对象<code>stmt</code>执行查询时创建<code>ResultSet</code> <code>rs</code> 。请注意，可以通过实现<code>Statement</code>接口的任何对象创建<code>ResultSet</code>对象，包括<code>PreparedStatement</code> ， <code>CallableStatement</code>和<code>RowSet</code> 。</p>
<p>您可以通过游标访问<code>ResultSet</code>对象中的数据。请注意，此游标不是数据库游标。此游标是指向<code>ResultSet</code>一行数据的指针。最初，光标位于第一行之前。<code>ResultSet.next</code>方法将光标移动到下一行。如果光标位于最后一行之后，则此方法返回<code>false</code> 。此方法使用<code>while</code>循环重复调用<code>ResultSet.next</code>方法以遍历<code>ResultSet</code>中的所有数据。</p>
<p>此页面包含以下主题：</p>
<ul>
<li><a href="#rs_interface">ResultSet接口</a></li>
<li><a href="#retrieve_rs">从行检索列值</a></li>
<li><a href="#cursors">游标</a></li>
<li><a href="#rs_update">更新ResultSet对象中的行</a></li>
<li><a href="#batch_updates">使用语句对象进行批量更新</a></li>
<li><a href="#rs_insert">在ResultSet对象中插入行</a></li>
</ul>
<!-- **************************************** -->
<h2><a name="rs_interface" id="rs_interface">ResultSet接口</a></h2>
<p><code>ResultSet</code>接口提供了检索和操作已执行查询结果的方法， <code>ResultSet</code>对象可以具有不同的功能和特征。这些特征是类型，并发和光标<em>可保存性</em> 。</p>
<!-- ==================================== -->
<h3>ResultSet类型</h3>
<p><code>ResultSet</code>对象的类型在两个区域中确定其功能级别：可以操作游标的方式，以及<code>ResultSet</code>对象如何反映对基础数据源的并发更改。</p>
<p><code>ResultSet</code>对象的敏感性由三种不同的<code>ResultSet</code>类型之一确定：</p>
<ul>
<li><code>TYPE_FORWARD_ONLY</code> ：无法滚动结果集;它的光标仅向前移动，从第一行之前到最后一行之后。结果集中包含的行取决于底层数据库如何生成结果。也就是说，它包含在执行查询时或检索行时满足查询的行。</li>
<li><code>TYPE_SCROLL_INSENSITIVE</code> ：结果可以滚动;它的光标可以相对于当前位置向前和向后移动，并且它可以移动到绝对位置。结果集对基础数据源打开时所做的更改不敏感。它包含在执行查询时或检索行时满足查询的行。</li>
<li><code>TYPE_SCROLL_SENSITIVE</code> ：结果可以滚动;它的光标可以相对于当前位置向前和向后移动，并且它可以移动到绝对位置。结果集反映了在结果集保持打开状态时对基础数据源所做的更改。</li>
</ul>
<p>默认的<code>ResultSet</code>类型是<code>TYPE_FORWARD_ONLY</code> 。</p>
<p><strong>注意</strong> ：并非所有数据库和JDBC驱动程序都支持所有<code>ResultSet</code>类型。如果支持指定的<code>ResultSet</code>类型，则<code>DatabaseMetaData.supportsResultSetType</code>方法返回<code>true</code>否则返回<code>false</code> 。</p>
<!-- ==================================== -->
<h3>ResultSet并发</h3>
<p><code>ResultSet</code>对象的并发性确定支持的更新功能级别。</p>
<p>有两个并发级别：</p>
<ul>
<li><code>CONCUR_READ_ONLY</code> ：无法使用<code>ResultSet</code>接口更新<code>ResultSet</code>对象。</li>
<li><code>CONCUR_UPDATABLE</code> ：可以使用<code>ResultSet</code>接口更新<code>ResultSet</code>对象。</li>
</ul>
<p>默认的<code>ResultSet</code>并发性是<code>CONCUR_READ_ONLY</code> 。</p>
<p><strong>注意</strong> ：并非所有JDBC驱动程序和数据库都支持并发。如果驱动程序支持指定的并发级别，则<code>DatabaseMetaData.supportsResultSetConcurrency</code>方法返回<code>true</code>否则返回<code>false</code> 。</p>
<p>方法<code><a href="gettingstarted.html">CoffeesTable.modifyPrices</a></code>演示了如何使用并发级别为<code>CONCUR_UPDATABLE</code>的<code>ResultSet</code>对象。</p>
<!-- ==================================== -->
<h3>光标可保持性</h3>
<p>调用<code>Connection.commit</code>方法可以关闭在当前事务期间创建的<code>ResultSet</code>对象。但是，在某些情况下，这可能不是理想的行为。该<code>ResultSet</code>财产<em>可保存性</em>给出了是否应用控制<code>ResultSet</code>被调用时提交对象（游标）关闭。</p>
<p>可以将以下<code>ResultSet</code>常量提供给<code>Connection</code>方法<code>createStatement</code> ， <code>prepareStatement</code>和<code>prepareCall</code> ：</p>
<ul>
<li><code>HOLD_CURSORS_OVER_COMMIT</code> ： <code>ResultSet</code>游标未关闭;它们是可<em>保持的</em> ：在调用方法<code>commit</code>时它们保持打开状态。如果您的应用程序主要使用只读<code>ResultSet</code>对象，则可保持游标可能是理想的。</li>
<li><code>CLOSE_CURSORS_AT_COMMIT</code> ：调用<code>commit</code>方法时， <code>ResultSet</code>对象（游标）将关闭。调用此方法时关闭游标可以为某些应用程序带来更好的性能。</li>
</ul>
<p>默认光标可保持性因DBMS而异。</p>
<p><strong>注意</strong> ：并非所有JDBC驱动程序和数据库都支持可保持和不可保留的游标。以下方法<code>JDBCTutorialUtilities.cursorHoldabilitySupport</code>输出<code>ResultSet</code>对象的默认游标可保持性以及是否支持<code>HOLD_CURSORS_OVER_COMMIT</code>和<code>CLOSE_CURSORS_AT_COMMIT</code> ：</p>
<div class="codeblock"><pre>public static void cursorHoldabilitySupport（Connection conn）抛出SQLException {DatabaseMetaData dbMetaData = conn.getMetaData（）;的System.out.println（“结果集。HOLD_CURSORS_OVER_COMMIT =“+ ResultSet。HOLD_CURSORS_OVER_COMMIT）;的System.out.println（“结果集。CLOSE_CURSORS_AT_COMMIT =“+ ResultSet。CLOSE_CURSORS_AT_COMMIT）; System.out.println（“Default cursor <strong>holdability</strong> ：”+ <strong>dbMetaData.getResultSetHoldability（）</strong> ）; System.out.println（“支持HOLD_CURSORS_OVER_COMMIT？“+ <strong>dbMetaData.supportsResultSetHoldability（ResultSet。HOLD_CURSORS_OVER_COMMIT）</strong> ）; System.out.println（“支持CLOSE_CURSORS_AT_COMMIT？“+ <strong>dbMetaData.supportsResultSetHoldability（ResultSet。CLOSE_CURSORS_AT_COMMIT）</strong> ）; }</pre></div>
<!-- ********************************************* -->
<h2><a name="retrieve_rs" id="retrieve_rs">从行检索列值</a></h2>
<p><code>ResultSet</code>接口声明getter方法（例如， <code>getBoolean</code>和<code>getLong</code> ），用于从当前行检索列值。您可以使用列的索引号或列的别名或名称来检索值。列索引通常更有效。列从1开始编号。为了获得最大的可移植性，应按从左到右的顺序读取每行中的结果集列，并且每列应只读一次。</p>
<p>例如，以下方法<code><a href="gettingstarted.html">CoffeesTable.alternateViewTable</a></code>按编号检索列值：</p>
<div class="codeblock"><pre>public static void alternateViewTable（Connection con）抛出SQLException {Statement stmt = null;字符串查询=“选择COF_NAME，SUP_ID，PRICE，”+“SALES，COOTEES总计”; try {stmt = con.createStatement（）; ResultSet rs = stmt.executeQuery（query）; while（rs.next（））{String coffeeName = rs.getString（1）; int supplierID = rs.getInt（2）; float price = rs.getFloat（3）; int sales = rs.getInt（4）; int total = rs.getInt（5）; System.out.println（coffeeName +“\ t”+ supplierID +“\ t”+ price +“\ t”+ sales +“\ t”+ total）; catch（SQLException e）{JDBCTutorialUtilities.printSQLException（e）;终于{if（stmt！）= null）{stmt.close（）; }}}</pre></div>
<p>用作getter方法输入的字符串不区分大小写。当使用字符串调用getter方法并且多个列具有与字符串相同的别名或名称时，将返回第一个匹配列的值。使用字符串而不是整数的选项设计用于在生成结果集的SQL查询中使用列别名和名称时使用。对于<em>未</em>在查询中明确命名的列（例如， <code>select * from COFFEES</code> ），最好使用列号。如果使用列名，开发人员应保证使用列别名唯一引用预期的列。列别名有效地重命名结果集的列。要指定列别名，请在<code>SELECT</code>语句中使用SQL <code>AS</code>子句。</p>
<p>适当类型的getter方法检索每列中的值。例如，在方法<code><a href="gettingstarted.html">CoffeeTables.viewTable</a></code> ， <code>ResultSet</code> <code>rs</code>每一行中的第一列是<code>COF_NAME</code> ，它存储SQL类型<code>VARCHAR</code>的值。检索SQL类型<code>VARCHAR</code>的值的方法是<code>getString</code> 。每行中的第二列存储SQL类型<code>INTEGER</code>的值，并且用于检索该类型的值的方法是<code>getInt</code> 。</p>
<p>请注意，尽管建议使用<code>getString</code>方法来检索SQL类型<code>CHAR</code>和<code>VARCHAR</code> ，但可以使用它检索任何基本SQL类型。使用<code>getString</code>获取所有值可能非常有用，但它也有其局限性。例如，如果它用于检索数字类型，则<code>getString</code>将数值转换为Java <code>String</code>对象，并且必须先将值转换回数字类型，然后才能将其作为数字进行操作。在无论如何将值视为字符串的情况下，没有任何缺点。此外，如果希望应用程序检索除SQL3类型之外的任何标准SQL类型的值，请使用<code>getString</code>方法。</p>
<!-- ********************************************* -->
<h2><a name="cursors" id="cursors">游标</a></h2>
<p>如前所述，您可以通过游标访问<code>ResultSet</code>对象中的数据，该游标指向<code>ResultSet</code>对象中的一行。但是，首次创建<code>ResultSet</code>对象时，光标位于第一行之前。<code><a href="gettingstarted.html">CoffeeTables.viewTable</a></code>方法通过调用<code>ResultSet.next</code>方法<code><a href="gettingstarted.html">CoffeeTables.viewTable</a></code>移动游标。还有其他可用于移动光标的方法：</p>
<ul>
<li><code>next</code> ：将光标向前移动一行。如果光标现在位于行上，则返回<code>true</code>如果光标位于最后一行之后，则返回<code>false</code> 。</li>
<li><code>previous</code> ：将光标向后移动一行。如果光标现在位于行上，则返回<code>true</code>如果光标位于第一行之前，则返回<code>false</code> 。</li>
<li><code>first</code> ：将光标移动到<code>ResultSet</code>对象的第一行。如果光标现在位于第一行，则返回<code>true</code>如果<code>ResultSet</code>对象不包含任何行，则<code>ResultSet</code> <code>false</code> 。</li>
<li><code>last:</code>将光标移动到<code>ResultSet</code>对象的最后一行。如果光标现在位于最后一行，则返回<code>true</code>如果<code>ResultSet</code>对象不包含任何行，则<code>ResultSet</code> <code>false</code> 。</li>
<li><code>beforeFirst</code> ：将光标定位在<code>ResultSet</code>对象的开头，在第一行之前。如果<code>ResultSet</code>对象不包含任何行，则此方法无效。</li>
<li><code>afterLast</code> ：将光标定位在<code>ResultSet</code>对象的最后一行之后。如果<code>ResultSet</code>对象不包含任何行，则此方法无效。</li>
<li><code>relative(int rows)</code> ：相对于当前位置移动光标。</li>
<li><code>absolute(int row)</code> ：将光标定位在参数<code>row</code>指定的<code>row</code> 。</li>
</ul>
<p>请注意， <code>ResultSet</code>的默认灵敏度为<code>TYPE_FORWARD_ONLY</code> ，这意味着它无法滚动;如果无法滚动<code>ResultSet</code> ，则无法调用任何移动光标的方法（ <code>next</code>除外）。<code><a href="gettingstarted.html">CoffeesTable.modifyPrices</a></code>中描述的方法<code><a href="gettingstarted.html">CoffeesTable.modifyPrices</a></code>演示了如何移动<code>ResultSet</code>的光标。</p>
<!-- ********************************************* -->
<h2><a name="rs_update" id="rs_update">更新ResultSet对象中的行</a></h2>
<p>您无法更新默认的<code>ResultSet</code>对象，并且只能向前移动其光标。但是，您可以创建可以滚动的<code>ResultSet</code>对象（光标可以向后移动或移动到绝对位置）并更新。</p>
<p>以下方法<code><a href="gettingstarted.html">CoffeesTable.modifyPrices</a></code>将每行的<code>PRICE</code>列乘以参数<code>percentage</code> ：</p>
<div class="codeblock"><pre>public void modifyPrices（float percentage）throws SQLException {Statement stmt = null; try {stmt = con.createStatement（）; stmt = con.createStatement（ResultSet。TYPE_SCROLL_SENSITIVE，ResultSet。CONCUR_UPDATABLE）; ResultSet uprs = stmt.executeQuery（“SELECT * FROM”+ dbName +“。COFFEES“）; while（uprs.next（））{float f = uprs.getFloat（”PRICE“）; uprs.updateFloat（”PRICE“，f * percentage）; uprs.updateRow（）;}} catch（SQLException e ）{JDBCTutorialUtilities.printSQLException（e）;} finally {if（stmt！）= null）{stmt.close（）; }}}</pre></div>
<p>字段<code>ResultSet.TYPE_SCROLL_SENSITIVE</code>创建一个<code>ResultSet</code>对象，其光标可以相对于当前位置向前和向后移动到绝对位置。字段<code>ResultSet.CONCUR_UPDATABLE</code>创建一个可以更新的<code>ResultSet</code>对象。有关可以指定用于修改<code>ResultSet</code>对象行为的其他字段，请参阅<code>ResultSet</code> Javadoc。</p>
<p><code>ResultSet.updateFloat</code>方法更新指定的列（在此示例中， <code>PRICE</code>在光标所在的行中具有指定的<code>float</code>值。<code>ResultSet</code>包含各种更新程序方法，使您可以更新各种数据类型的列值。但是，这些更新程序方法都不会修改数据库;您必须调用方法<code>ResultSet.updateRow</code>来更新数据库。</p>
<!-- ********************************************* -->
<h2><a name="batch_updates" id="batch_updates">使用语句对象进行批量更新</a></h2>
<p><code>Statement</code> ， <code>PreparedStatement</code>和<code>CallableStatement</code>对象具有与之关联的命令列表。该列表可能包含更新，插入或删除行的语句;它还可能包含DDL语句，如<code>CREATE TABLE</code>和<code>DROP TABLE</code> 。但是，它不能包含将生成<code>ResultSet</code>对象的语句，例如<code>SELECT</code>语句。换句话说，列表只能包含产生更新计数的语句。</p>
<p>该列表在创建时与<code>Statement</code>对象关联，最初为空。您可以使用方法<code>addBatch</code>将SQL命令添加到此列表中，并使用<code>addBatch</code>方法将其<code>clearBatch</code> 。完成向列表添加语句后，调用<code>executeBatch</code>方法将它们全部发送到数据库，以便作为一个单元或批处理执行。</p>
<p>例如，以下方法<code><a href="gettingstarted.html">CoffeesTable.batchUpdate</a></code>通过批量更新向<code>COFFEES</code>表添加四行：</p>
<div class="codeblock"><pre>public void batchUpdate（）throws SQLException {Statement stmt = null;试试{this.con.setAutoCommit（false）; stmt = this.con.createStatement（）; stmt.addBatch（“INSERT INTO COFFEES”+“VALUES（'Amaretto'，49,9.99,0,0）”）; stmt.addBatch（“INSERT INTO COFFEES”+“VALUES（'Hazelnut'，49,9.99,0,0）”）; stmt.addBatch（“INSERT INTO COFFEES”+“VALUES（'Amaretto_decaf'，49，”+“10.99,0,0）”）; stmt.addBatch（“INSERT INTO COFFEES”+“VALUES（'Hazelnut_decaf'，49，”+“10.99,0,0）”）; int [] updateCounts = stmt.executeBatch（）; this.con.commit（）; } catch（BatchUpdateException b）{JDBCTutorialUtilities.printBatchUpdateException（b）; } catch（SQLException ex）{JDBCTutorialUtilities.printSQLException（ex）;终于{if（stmt！）= null）{stmt.close（）; } this.con.setAutoCommit（true）; }}</pre></div>
<p>以下行禁用<code>Connection</code>对象con的自动提交模式，以便在调用方法<code>executeBatch</code>时不会自动提交或回滚事务。</p>
<div class="codeblock"><pre>this.con.setAutoCommit（假）;</pre></div>
<p>要允许正确的错误处理，应始终在开始批量更新之前禁用自动提交模式。</p>
<p><code>Statement.addBatch</code>方法将命令添加到与<code>Statement</code>对象<code>stmt</code>关联的命令列表中。在此示例中，这些命令都是<code>INSERT INTO</code>语句，每个语句都添加一个由五个列值组成的行。<code>COF_NAME</code>和<code>PRICE</code>列的值分别是咖啡的名称及其价格。每行中的第二个值为49，因为这是供应商Superior Coffee的标识号。最后两个值，列<code>SALES</code>和<code>TOTAL</code>的条目，都开始为零，因为还没有销售。（ <code>SALES</code>是本周销售的这一排咖啡的磅数; <code>TOTAL</code>是这种咖啡累计销售额的总和。）</p>
<p>以下行将添加到其命令列表中的四个SQL命令发送到要作为批处理执行的数据库：</p>
<div class="codeblock"><pre>int [] updateCounts = stmt.executeBatch（）;</pre></div>
<p>请注意， <code>stmt</code>使用<code>executeBatch</code>方法发送一批插入，而不是方法<code>executeUpdate</code> ，它只发送一个命令并返回单个更新计数。DBMS按照将它们添加到命令列表的顺序执行命令，因此它将首先为Amaretto添加值行，然后为Hazelnut添加行，然后添加Amaretto decaf，最后添加Hazelnut decaf。如果所有四个命令都成功执行，则DBMS将按照执行顺序为每个命令返回更新计数。指示每个命令影响的行数的更新计数存储在数组<code>updateCounts</code> 。</p>
<p>如果批处理中的所有四个命令都成功执行，则<code>updateCounts</code>将包含四个值，所有这些值都是1，因为插入会影响一行。与<code>stmt</code>关联的命令列表现在将为空，因为当<code>stmt</code>调用方法<code>executeBatch</code>时，先前添加的四个命令被发送到数据库。您可以随时使用<code>clearBatch</code>方法显式清空此命令列表。</p>
<p><code>Connection.commit</code>方法使<code>COFFEES</code>表的批量更新成为永久性。需要显式调用此方法，因为此连接的自动提交模式先前已禁用。</p>
<p>以下行为当前<code>Connection</code>对象启用自动提交模式。</p>
<div class="codeblock"><pre>this.con.setAutoCommit（真）;</pre></div>
<p>现在，示例中的每个语句将在执行后自动提交，并且不再需要调用方法<code>commit</code> 。</p>
<h3>执行参数化批量更新</h3>
<p>也可以进行参数化批量更新，如下面的代码片段所示，其中<code>con</code>是<code>Connection</code>对象：</p>
<div class="codeblock"><pre>con.setAutoCommit（假）; PreparedStatement pstmt = con.prepareStatement（“INSERT INTO COFFEES VALUES（”+“？，？，？，？，？）“）; pstmt.setString（1，”Amaretto“）; pstmt.setInt（2,49）; pstmt.setFloat（3,9.99）; pstmt.setInt（4,0）; pstmt.setInt（5,0）; pstmt.addBatch（）; pstmt.setString（1，“Hazelnut”）; pstmt.setInt（2,49）; pstmt.setFloat（3,9.99）; pstmt.setInt（4,0）; pstmt.setInt（5， 0）; pstmt.addBatch（）; <strong>// ...等等每个新的//类型的咖啡</strong> int [] updateCounts = pstmt.executeBatch（）; con.commit（）; con.setAutoCommit（true）;</pre></div>
<h3>处理批量更新例外</h3>
<p>如果（1）您添加到批处理中的一个SQL语句生成结果集（通常是查询）或（2）批处理中的一个SQL语句未成功执行，则在调用方法<code>executeBatch</code>时将收到<code>BatchUpdateException</code>出于其他原因。</p>
<p>您不应该向一批SQL命令添加查询（ <code>SELECT</code>语句），因为返回更新计数数组的<code>executeBatch</code>方法需要每个成功执行的SQL语句的更新计数。这意味着只有返回更新计数的命令（诸如<code>INSERT INTO</code> ， <code>UPDATE</code> ， <code>DELETE</code> ）或返回0的命令（例如<code>CREATE TABLE</code> ， <code>DROP TABLE</code> ， <code>ALTER TABLE</code> ）才能使用<code>executeBatch</code>方法成功执行。</p>
<p><code>BatchUpdateException</code>包含一个更新计数数组，类似于<code>executeBatch</code>方法返回的数组。在这两种情况下，更新计数的顺序与生成它们的命令的顺序相同。这将告诉您批处理中有多少命令成功执行以及它们是哪些命令。例如，如果成功执行了五个命令，则该数组将包含五个数字：第一个是第一个命令的更新计数，第二个是第二个命令的更新计数，依此类推。</p>
<p><code>BatchUpdateException</code>派生自<code>SQLException</code> 。这意味着您可以使用<code>SQLException</code>对象可用的所有方法。以下方法<code><a href="gettingstarted.html">JDBCTutorialUtilities.printBatchUpdateException</a></code>打印所有<code>SQLException</code>信息以及<code>BatchUpdateException</code>对象中包含的更新计数。因为<code>BatchUpdateException.getUpdateCounts</code>返回一个<code>int</code>数组，所以代码使用<code>for</code>循环来打印每个更新计数：</p>
<div class="codeblock"><pre>public static void printBatchUpdateException（BatchUpdateException b）{System.err.println（“---- BatchUpdateException ----”）; System.err.println（“SQLState：”+ b.getSQLState（））; System.err.println（“Message：”+ b.getMessage（））; System.err.println（“Vendor：”+ b.getErrorCode（））; System.err.print（“Update counts：”）; int [] updateCounts = b.getUpdateCounts（）; for（int i = 0; i &lt;updateCounts.length; i ++）{System.err.print（updateCounts [i] +“”）; }}</pre></div>
<!-- ********************************************* -->
<h2><a name="rs_insert" id="rs_insert">在ResultSet对象中插入行</a></h2>
<p><strong>注意</strong> ：并非所有JDBC驱动程序都支持使用<code>ResultSet</code>接口插入新行。如果尝试插入新行且JDBC驱动程序数据库不支持此功能，则会引发<code>SQLFeatureNotSupportedException</code>异常。</p>
<p>以下方法<code><a href="gettingstarted.html">CoffeesTable.insertRow</a></code>通过<code>ResultSet</code>对象将一行插入<code>COFFEES</code> ：</p>
<div class="codeblock"><pre>public void insertRow（String coffeeName，int supplierID，float price，int sales，int total）throws SQLException {Statement stmt = null; try {stmt = con.createStatement（ResultSet。TYPE_SCROLL_SENSITIVE ResultSet。CONCUR_UPDATABLE）; ResultSet uprs = stmt.executeQuery（“SELECT * FROM”+ dbName +“。COFFEES“）; uprs.moveToInsertRow（）; uprs.updateString（”COF_NAME“，coffeeName）; uprs.updateInt（”SUP_ID“，supplierID）; uprs.updateFloat（”PRICE“，price）; uprs.updateInt（”SALES“） ，sales）; uprs.updateInt（“TOTAL”，total）; uprs.insertRow（）; uprs.beforeFirst（）;} catch（SQLException e）{JDBCTutorialUtilities.printSQLException（e）;} finally {if（stmt！）= null）{stmt.close（）; }}}</pre></div>
<p>此示例使用两个参数<code>ResultSet.调用<code>Connection.createStatement</code>方法<code>ResultSet.TYPE_SCROLL_SENSITIVE</code>和<code>ResultSet.CONCUR_UPDATABLE</code> 。第一个值使<code>ResultSet</code>对象的光标可以向前和向后移动。第二个值， <code>ResultSet.如果要将行插入<code>ResultSet</code>对象，则需要CONCUR_UPDATABLE</code> ;它指定它可以更新。</p>
<p>在getter方法中使用字符串的相同规定也适用于更新程序方法。</p>
<p><code>ResultSet.moveToInsertRow</code>方法将光标移动到插入行。插入行是与可更新结果集关联的特殊行。它本质上是一个缓冲区，可以通过在将行插入结果集之前调用updater方法来构造新行。例如，此方法调用<code>ResultSet.updateString</code>方法将插入行的<code>COF_NAME</code>列更新为<code>Kona</code> 。</p>
<p><code>ResultSet.insertRow</code>方法将插入行的内容插入到<code>ResultSet</code>对象和数据库中。</p>
<p><strong>注意</strong> ：使用<code>ResultSet.insertRow</code>插入行后，应将光标移动到插入行以外的行。例如，此示例使用方法<code>ResultSet.beforeFirst</code>将其移动到结果集中的第一行之前。如果应用程序的另一部分使用相同的结果集并且光标仍指向插入行，则可能会出现意外结果。</p>
<!-- ***************************************** -->


        </div>
        <div class="NavBit">
            <a href="tables.html" target="_top">«上一页</a> • <a href="../TOC.html" target="_top">小道</a> • <a href="prepared.html" target="_top">下一页»</a>
        </div>
    </div>
    
<hr class="clearfloat">

<div id="Footer">

<p class="footertext">
<a href="http://www.oracle.com/corporate/index.html">关于Oracle</a> | <a href="http://www.oracle.com/us/corporate/contact/index.html">联系我们</a> | <a href="http://www.oracle.com/us/legal/index.html">法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href="http://www.oracle.com/us/legal/privacy/index.html">您的隐私权</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&amp;id=en-US">版权所有©1995,2017 Oracle和/或其附属公司。版权所有。</a></p>
       
</div>    
    <div class="PrintHeaders">
        <b>上一页：</b>设置表格<br><b>下一页：</b>使用准备好的语句</div>
<!-- Start SiteCatalyst code -->
<script type="application/javascript" src="https://www.oracleimg.com/us/assets/metrics/ora_docs.js"></script>
<!-- End SiteCatalyst code --> 
</body>
</html>