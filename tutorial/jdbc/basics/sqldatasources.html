<html lang="en-US" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>与DataSource对象连接（Java™教程&gt; JDBC（TM）数据库访问&gt; JDBC基础知识）</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
     <meta name="description" content="This JDBC Java tutorial describes how to use JDBC API to create, insert into, update, and query tables. You will also learn how to use simple and prepared statements, stored procedures and perform transactions"></meta>
     <meta name="keywords" content="java programming, learn java, java sample code, jdbc, prepared statement, result set"></meta>
        
<style type="text/css">body {
  margin-left: 10px;
  margin-right: 10px;
  line-height: 1.5;
  FONT-FAMILY: Arial,Helvetica,sans-serif;
  font-size: 0.8em;
}
a:link {
  text-decoration: none;
  color: #09569d;
}
a:visited {
  text-decoration: none;
  color: #3a87cf;
}
a:hover {
  text-decoration: underline;
}
code {
  font-family: Monaco,Courier,"Courier New";
}
.header-container {
  background-color: #fff;
  border-bottom: 1px solid #c1cfda;
  -webkit-box-shadow: 0 2px 2px rgba(117,163,231,0.1);
  box-shadow: 0 2px 2px rgba(117,163,231,0.1);
}
.bookwrapper {
  width: auto;
  margin: auto;
}
.clearfix {
}
.clearfloat {
  clear: both;
  overflow: auto;
  height: 0px;
  font-size: 1px;
  line-height: 0px;
}
#brandProdName {
  width: auto;
  height: auto;
}
#logocover {
  display: block;
  background: transparent url('../../images/oracle-java-logo.png') 0px 0px no-repeat;
  height: 50px;
  width: 229px;
  float: left;
}
#productName {
  font-size: 16px;
  position: relative;
  top: 19px;
  padding-left: 3px;
  color: #457798;
  white-space: nowrap;
  width: 340px;
}
.FigureCaption {
  font-family: sans-serif;
  text-align: center;
}
#TopBar_bl {
  width: 100%;
  height: 60px;
}
#TopBar_br {
  width: 100%;
  height: 60px;
}
#TopBar_tl {
  margin-left: -110px;
  margin-right: -100px;
  align: left;
  height: 60px;
}
#TopBar_tr {
  width: 100%;
  height: 60px;
}
#TopBar {
  min-width: 700px;
  padding: 25px 100px 10px;
  margin-bottom: 25px;
  clear: both;
  border-bottom: 1px solid #d2dde5;
  border-radius: 3px;
  background: #efefef;
  /* Old browsers */
  /* IE9 SVG, needs conditional override of 'filter' to 'none' */
  
  background: -moz-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* FF3.6+ */
  background: -webkit-gradient(linear,left top,left bottom,color-stop(0%,#ffffff),color-stop(100%,#e2eff9));
  /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* Opera 11.10+ */
  background: -ms-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* IE10+ */
  background: linear-gradient(to bottom,#ffffff 0%,#e2eff9 100%);
  /* W3C */
  /* IE6-8 */
}
#TopBar_left {
  line-height: 14px;
  position: absolute;
  padding-top: 30px;
  padding-right: 30px;
  padding-left: 30px;
  text-align: left;
  font: 13px/20px Arial,Helvetica,sans-serif;
  font-weight: bold;
  font-size: 20px;
  color: #333;
}
#TopBar_right {
  line-height: 12px;
  float: right;
  padding-top: 10px;
  padding-right: 30px;
  text-align: left;
}
@media print {
  #BreadCrumbs, #Download {
    display: none;
  }
}
@media print {
  #TopBar_right {
    display: none;
  }
}
#TopBar_right a {
  font-size: 10px;
  margin: 3px;
  padding: 0;
}
#BreadCrumbs {
  padding: 15px 5px 0.5em 0;
  font-family: sans-serif;
  float: right;
}
#BreadCrumbs a {
  color: #09569d;
}
#BreadCrumbs a:visited, #BreadCrumbs a:link {
  text-decoration: none;
}
#BreadCrumbs a:hover, #BreadCrumbs a:active {
  text-decoration: underline;
}
#PageTitle {
  margin: 0 5px 0.5em 0;
  color: #f90000;
}
#PageContent {
  margin: 0 5px 0 20px;
}
.LeftBar_shown {
  width: 13em;
  float: left;
}
@media print {
  .LeftBar_shown {
    display: none;
  }
}
.LeftBar_hidden {
  display: none;
}
#Footer {
  padding-top: 10px;
  padding-left: 10px;
  margin-right: 10px;
}
.footertext {
  font-size: 10px;
  font-family: sans-serif;
  margin-top: 1px;
}
.NavBit {
  padding: 15px 5px 0.5em 0;
  font-family: sans-serif;
}
@media print {
  .NavBit {
    display: none;
  }
}
#TagNotes {
  text-align: right;
}
@media print {
  #TagNotes a:visited, #TagNotes a:link {
    color: #35556b;
    text-decoration: none;
  }
}
#Contents a, .NavBit a, #TagNotes a {
  color: #09569d;
}
#TagNotes a:visited, #TagNotes a:link, #Contents a:visited, #Contents a:link, .NavBit a:visited, .NavBit a:link {
  text-decoration: none;
}
#TagNotes a:hover, #TagNotes a:active, #Contents a:hover, #Contents a:active, .NavBit a:hover, .NavBit a:active {
  text-decoration: underline;
}
#Contents {
  float: left;
  font-family: sans-serif;
}
@media print {
  #Contents {
    display: none;
  }
}
@media screen {
  div.PrintHeaders {
    display: none;
  }
}
.linkLESSON, .nolinkLESSON {
  margin-left: 0.5em;
  text-indent: -0.5em;
}
.linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS {
  margin-left: 1.5em;
  text-indent: -0.5em;
}
.linkBHEAD, .nolinkBHEAD {
  margin-left: 2.5em;
  text-indent: -0.5em;
}
.linkCHEAD, .nolinkCHEAD {
  margin-left: 3.5em;
  text-indent: -0.5em;
}
.nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD, .nolinkQUESTIONS {
  font-weight: bold;
  color: #333;
}
.MainFlow_indented {
  margin-right: 10px;
  margin-left: 15em;
  margin-bottom: 2em;
}
.MainFlow_wide {
  margin-right: 10px;
  margin-left: 10px;
  margin-bottom: 2em;
}
@media print {
  .MainFlow_indented, .MainFlow_wide {
    padding-top: 0;
    margin-top: 10px;
    margin-right: 10px;
    margin-left: 0;
  }
}
h1, h2, h3, h4, h5 {
  color: #333;
}
h1 {
  font-weight: bold;
  font-size: 20px;
}
h2 {
  font-weight: bold;
  font-size: 17px;
}
h3 {
  font-weight: bold;
  font-size: 14px;
}
h4 {
  font-size: 15px;
}
h5 {
  font-size: 12px;
}
#ToggleLeft {
  display: none;
}
.note {
  margin: 0 30px 0px 30px;
}
.codeblock {
  margin: 0 30px 0px 30px;
  font-size: 12px;
  font-family: Monaco,Courier,"Courier New";
}
.tocli {
  list-style-type: none;
}
.betadraft {
  color: red;
}
</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body dir="ltr" onload="load()">
    <noscript>启用了JavaScript的浏览器需要此页面正常运行。
    </noscript>
        <!-- header -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文档</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr">
            <div id="TopBar_tl">
                <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                        <div id="TopBar_right"> 
                            <!--
                            <a href="URL" target="_blank">External Link</a><br/>
                            --> <a href="javascript:void(0);" id="ToggleLeft">隐藏TOC</a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="linkLESSON"><a href="index.html">JDBC基础知识</a></div>
<div class="linkAHEAD"><a href="gettingstarted.html">入门</a></div>
<div class="linkAHEAD"><a href="processingsqlstatements.html">使用JDBC处理SQL语句</a></div>
<div class="linkAHEAD"><a href="connecting.html">建立连接</a></div>
<div class="nolinkAHEAD">连接数据源对象</div>
<div class="linkAHEAD"><a href="sqlexception.html">处理SQLExceptions</a></div>
<div class="linkAHEAD"><a href="tables.html">设置表</a></div>
<div class="linkAHEAD"><a href="retrieving.html">从结果集中检索和修改值</a></div>
<div class="linkAHEAD"><a href="prepared.html">使用准备好的陈述</a></div>
<div class="linkAHEAD"><a href="transactions.html">使用交易</a></div>
<div class="linkAHEAD"><a href="rowset.html">使用RowSet对象</a></div>
<div class="linkAHEAD"><a href="jdbcrowset.html">使用JdbcRowSet对象</a></div>
<div class="linkAHEAD"><a href="cachedrowset.html">使用CachedRowSetObjects</a></div>
<div class="linkAHEAD"><a href="joinrowset.html">使用JoinRowSet对象</a></div>
<div class="linkAHEAD"><a href="filteredrowset.html">使用FilteredRowSet对象</a></div>
<div class="linkAHEAD"><a href="webrowset.html">使用WebRowSet对象</a></div>
<div class="linkAHEAD"><a href="sqltypes.html">使用高级数据类型</a></div>
<div class="linkAHEAD"><a href="blob.html">使用大对象</a></div>
<div class="linkAHEAD"><a href="sqlxml.html">使用SQLXML对象</a></div>
<div class="linkAHEAD"><a href="array.html">使用数组对象</a></div>
<div class="linkAHEAD"><a href="distinct.html">使用DISTINCT数据类型</a></div>
<div class="linkAHEAD"><a href="sqlstructured.html">使用结构化对象</a></div>
<div class="linkAHEAD"><a href="sqlcustommapping.html">使用自定义类型映射</a></div>
<div class="linkAHEAD"><a href="sqldatalink.html">使用数据链接对象</a></div>
<div class="linkAHEAD"><a href="sqlrowid.html">使用RowId对象</a></div>
<div class="linkAHEAD"><a href="storedprocedures.html">使用存储过程</a></div>
<div class="linkAHEAD"><a href="jdbcswing.html">将JDBC与GUI API结合使用</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
    <div class="PrintHeaders">
        <b>Trail：</b> JDBC（TM）数据库访问<br><b>课程：</b> JDBC基础知识</div>
            <div id="BreadCrumbs">
                <a href="../../index.html" target="_top">主页</a> &gt; <a href="../index.html" target="_top">JDBC（TM）数据库访问</a> &gt; <a href="index.html" target="_top">JDBC基础知识</a>
            </div>
            <div class="NavBit">
                <a href="connecting.html" target="_top">«上一页</a> • <a href="../TOC.html" target="_top">小道</a> • <a href="sqlexception.html" target="_top">下一页»</a>
            </div>
            <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。本页中描述的示例和实践未利用后续版本中引入的改进。</p></div>
            <div id="PageTitle"><h1>连接数据源对象</h1></div>
            <div id="PageContent">

<!-- <h3>Connecting with DataSource Objects</h3> -->
<p>本节介绍<code>DataSource</code>对象，这是获取数据源连接的首选方法。除了将在后面解释的其他优点之外， <code>DataSource</code>对象还可以提供连接池和分布式事务。此功能对于企业数据库计算至关重要。特别是，它是Enterprise JavaBeans（EJB）技术不可或缺的一部分。</p>
<p>本节介绍如何使用<code>DataSource</code>接口建立连接以及如何使用分布式事务和连接池。这两者都涉及JDBC应用程序中很少的代码更改。</p>
<p>部署使这些操作成为可能的类（系统管理员通常使用工具（例如Apache Tomcat或Oracle WebLogic Server）执行）所执行的工作因所部署的<code>DataSource</code>对象的类型而异。因此，本节的大部分内容专门用于展示系统管理员如何设置环境，以便程序员可以使用<code>DataSource</code>对象来获取连接。</p>
<p>涵盖以下主题：</p>
<ul>
<li><a href="#datasource_connection">使用DataSource对象获取连接</a></li>
<li><a href="#deploy_datasource">部署基本数据源对象</a></li>
<li><a href="#datasource_implementation">部署其他DataSource实现</a></li>
<li><a href="#pooled_connection">获取和使用池连接</a></li>
<li><a href="#deployment_distributed_transactions">部署分布式事务</a></li>
<li><a href="#using_connections_distributed_transactions">使用分布式事务的连接</a></li>
</ul>
<!-- ************************************ -->
<h2><a name="datasource_connection" id="datasource_connection">使用DataSource对象获取连接</a></h2>
<p>在“ <a href="connecting.html">建立连接”中</a> ，您学习了如何使用<code>DriverManager</code>类建立连接。本节介绍如何使用<code>DataSource</code>对象获取与数据源的连接，这是首选方法。</p>
<p>由实现<code>DataSource</code>的类实例化的对象表示特定的DBMS或某些其他数据源，例如文件。<code>DataSource</code>对象表示特定的DBMS或某些其他数据源，例如文件。如果公司使用多个数据源，它将为每个数据源部署一个单独的<code>DataSource</code>对象。<code>DataSource</code>接口由驱动程序供应商实现。它可以通过三种不同的方式实现：</p>
<ul>
<li>基本<code>DataSource</code>实现生成标准<code>Connection</code>对象，这些对象未在分布式事务中合并或使用。</li>
<li>支持连接池的<code>DataSource</code>实现会生成参与连接池的<code>Connection</code>对象，即可以回收的连接。</li>
<li>支持分布式事务的<code>DataSource</code>实现生成可在分布式事务中使用的<code>Connection</code>对象，即访问两个或多个DBMS服务器的事务。</li>
</ul>
<p>JDBC驱动程序至少应包含一个基本的<code>DataSource</code>实现。例如，Java DB JDBC驱动程序包含<code>org.apache.derby.jdbc.实现<code>org.apache.derby.jdbc.ClientDataSource</code>和MySQL， <code>com.mysql.jdbc.jdbc2.optional.MysqlDataSource</code> 。如果您的客户端在Java 8 compact profile 2上运行，那么Java DB JDBC驱动程序是<code>org.apache.derby.jdbc.BasicClientDataSource40</code> 。本教程的示例需要紧凑的配置文件3或更高版本。</p>
<p>支持分布式事务的<code>DataSource</code>类通常还实现对连接池的支持。例如，EJB供应商提供的<code>DataSource</code>类几乎总是支持连接池和分布式事务。</p>
<p>假设从之前的例子开始，兴旺的咖啡店连锁店的所有者决定通过互联网销售咖啡进一步扩大。由于预计会有大量的在线业务，所有者肯定需要连接池。打开和关闭连接涉及大量开销，并且所有者预期该在线订购系统将需要大量的查询和更新。通过连接池，可以反复使用连接池，从而避免为每个数据库访问创建新连接的费用。此外，业主现在拥有第二个DBMS，其中包含最近收购的咖啡烘焙公司的数据。这意味着所有者希望能够编写使用旧DBMS服务器和新DBMS服务器的分布式事务。</p>
<p>连锁店主已经重新配置了计算机系统，以服务于新的更大的客户群。所有者购买了最新的JDBC驱动程序和与其一起使用的EJB应用程序服务器，以便能够使用分布式事务并获得连接池带来的更高性能。许多JDBC驱动程序可与最近购买的EJB服务器兼容。所有者现在具有三层体系结构，中间层有一个新的EJB应用程序服务器和JDBC驱动程序，第二层有两个DBMS服务器。发出请求的客户端计算机是第一层。</p>
<!-- ************************************ -->
<h2><a name="deploy_datasource" id="deploy_datasource">部署基本数据源对象</a></h2>
<p>系统管理员需要部署<code>DataSource</code>对象，以便Coffee Break的编程团队可以开始使用它们。部署<code>DataSource</code>对象包含三个任务：</p>
<ol>
<li>创建<code>DataSource</code>类的实例</li>
<li>设置其属性</li>
<li>将其注册为使用Java命名和目录接口（JNDI）API的命名服务</li>
</ol>
<p>首先，考虑最基本的情况，即使用<code>DataSource</code>接口的基本实现，即不支持连接池或分布式事务的接口。在这种情况下，只需要部署一个<code>DataSource</code>对象。<code>DataSource</code>的基本实现产生与<code>DriverManager</code>类生成的相同类型的连接。</p>
<!-- ====================================== -->
<h3>创建DataSource类的实例并设置其属性</h3>
<p>假设一个只想要<code>DataSource</code>基本实现的公司从JDBC供应商DB Access，Inc。购买了一个驱动程序。该驱动程序包含<code>com.dbaccess.类<code>com.dbaccess.BasicDataSource</code>实现了<code>DataSource</code>接口。以下代码摘录创建<code>BasicDataSource</code>类的实例并设置其属性。部署<code>BasicDataSource</code>实例后，程序员可以调用<code>DataSource.getConnection</code>方法来获取与公司数据库<code>CUSTOMER_ACCOUNTS</code> 。首先，系统管理员使用默认构造函数创建<code>BasicDataSource</code>对象<code><em>ds</em></code> 。然后系统管理员设置三个属性。请注意，以下代码通常由部署工具执行：</p>
<div class="codeblock"><pre>com.dbaccess。BasicDataSource ds = new com.dbaccess。的BasicDataSource（）; ds.setServerName（ “研磨机”）; ds.setDatabaseName（ “CUSTOMER_ACCOUNTS”）; ds.setDescription（“用于账单的客户账户数据库”）;</pre></div>
<p>变量<code><em>ds</em></code>现在表示服务器上安装的数据库<code>CUSTOMER_ACCOUNTS</code> 。<code>BasicDataSource</code>对象<code><em>ds</em></code>生成的任何连接都将是与数据库<code>CUSTOMER_ACCOUNTS</code>的连接。</p>
<!-- ====================================== -->
<h3>使用使用JNDI API的命名服务注册DataSource对象</h3>
<p>通过设置属性，系统管理员可以使用JNDI（Java命名和目录接口）命名服务注册<code>BasicDataSource</code>对象。使用的特定命名服务通常由系统属性确定，此处未显示。以下代码摘录注册<code>BasicDataSource</code>对象和与该逻辑名称绑定它<code>jdbc/billingDB</code> ：</p>
<div class="codeblock"><pre>Context ctx = new InitialContext（）; ctx.bind（“jdbc / billingDB”，ds）;</pre></div>
<p>此代码使用JNDI API。第一行创建一个<code>InitialContext</code>对象，该对象用作名称的起始点，类似于文件系统中的根目录。第二行相关联，或结合，所述<code>BasicDataSource</code>对象<code><em>ds</em></code>到逻辑名<code>jdbc/billingDB</code> 。在下一个代码摘录中，您为命名服务提供此逻辑名称，并返回<code>BasicDataSource</code>对象。逻辑名称可以是任何字符串。在这种情况下，公司决定使用名称<code>billingDB</code>作为<code>CUSTOMER_ACCOUNTS</code>数据库的逻辑名称。</p>
<p>在前面的示例中， <code>jdbc</code>是初始上下文下的子上下文，就像根目录下的目录是子目录一样。名称<code>jdbc/billingDB</code>类似于路径名，其中路径中的最后一项与文件名类似。在这种情况下， <code>billingDB</code>是给定所涉及的逻辑名<code>BasicDataSource</code>对象<code><em>ds</em></code> 。子上下文<code>jdbc</code>保留用于绑定到<code>DataSource</code>对象的逻辑名称，因此<code>jdbc</code>将始终是数据源的逻辑名称的第一部分。</p>
<h3>使用已部署的DataSource对象</h3>
<p>在系统管理员部署基本<code>DataSource</code>实现之后，程序员可以使用它。这意味着程序员可以提供绑定到<code>DataSource</code>类实例的逻辑数据源名称，JNDI命名服务将返回该<code>DataSource</code>类的实例。然后可以在该<code>DataSource</code>对象上调用<code>getConnection</code>方法，以获得与其表示的数据源的连接。例如，程序员可能会编写以下两行代码来获取一个<code>DataSource</code>对象，该对象生成与数据库<code>CUSTOMER_ACCOUNTS</code>的连接。</p>
<div class="codeblock"><pre>Context ctx = new InitialContext（）; DataSource ds =（DataSource）ctx.lookup（“jdbc / billingDB”）;</pre></div>
<p>第一行代码获取初始上下文作为检索<code>DataSource</code>对象的起点。当您将逻辑名称<code>jdbc/billingDB</code>给方法<code>lookup</code> ，该方法将返回系统管理员在部署时绑定到<code>jdbc/billingDB</code>的<code>DataSource</code>对象。由于方法<code>lookup</code>的返回值是Java <code>Object</code> ，因此在将其分配给变量<code><em>ds</em></code>之前，必须将其转换为更具体的<code>DataSource</code>类型。</p>
<p>变量<code><em>ds</em></code>是类<code>com.dbaccess.一个实例<code>com.dbaccess.BasicDataSource</code>实现了<code>DataSource</code>接口。调用<code><em>ds</em> .getConnection</code>方法会生成与<code>CUSTOMER_ACCOUNTS</code>数据库的连接。</p>
<div class="codeblock"><pre>连接con = ds.getConnection（“fernanda”，“brewed”）;</pre></div>
<p><code>getConnection</code>方法仅需要用户名和密码，因为变量<code><em>ds</em></code>具有在其属性中与<code>CUSTOMER_ACCOUNTS</code>数据库建立连接所需的其余信息，例如数据库名称和位置。</p>
<h3>DataSource对象的优点</h3>
<p>由于其属性， <code>DataSource</code>对象是获取连接的<code>DriverManager</code>类的更好选择。程序员不再需要在其应用程序中对驱动程序名称或JDBC URL进行硬编码，这使得它们更具可移植性。此外， <code>DataSource</code>属性使维护代码更加简单。如果有更改，系统管理员可以更新数据源属性，而不必担心更改连接到数据源的每个应用程序。例如，如果将数据源移动到其他服务器，则系统管理员所要做的就是将<code>serverName</code>属性设置为新的服务器名称。</p>
<p>除了可移植性和易维护性之外，使用<code>DataSource</code>对象获取连接还可以提供其他优势。当实现<code>DataSource</code>接口以使用<code>ConnectionPoolDataSource</code>实现时，该<code>DataSource</code>类的实例生成的所有连接将自动成为池连接。类似地，当实现<code>DataSource</code>实现以使用<code>XADataSource</code>类时，它生成的所有连接将自动成为可以在分布式事务中使用的连接。下一节将介绍如何部署这些类型的<code>DataSource</code>实现。</p>
<!-- ************************************ -->
<h2><a name="datasource_implementation" id="datasource_implementation">部署其他DataSource实现</a></h2>
<p>系统管理员或以该容量工作的其他人可以部署<code>DataSource</code>对象，以便它生成的连接是池连接。为此，他或她首先部署<code>ConnectionPoolDataSource</code>对象，然后部署实现的<code>DataSource</code>对象以使用它。设置<code>ConnectionPoolDataSource</code>对象的属性，以便它表示将生成连接的数据源。在向JNDI命名服务注册<code>ConnectionPoolDataSource</code>对象之后，将部署<code>DataSource</code>对象。通常，只能为<code>DataSource</code>对象设置两个属性： <code>description</code>和<code>dataSourceName</code> 。给<code>dataSourceName</code>属性赋予的值是标识先前部署的<code>ConnectionPoolDataSource</code>对象的逻辑名称，该对象包含进行连接所需的属性。</p>
<p>部署了<code>ConnectionPoolDataSource</code>和<code>DataSource</code>对象后，可以在<code>DataSource</code>对象上调用<code>DataSource.getConnection</code>方法并获得池化连接。此连接将连接到<code>ConnectionPoolDataSource</code>对象的属性中指定的数据源。</p>
<p>以下示例描述了The Coffee Break的系统管理员如何部署实现的<code>DataSource</code>对象以提供池化连接。系统管理员通常使用部署工具，因此本节中显示的代码片段是部署工具将执行的代码。</p>
<p>为了获得更好的性能，Coffee Break公司从DB Access，Inc。购买了一个包含<code>com.dbaccess.类的JDBC驱动程序<code>com.dbaccess.ConnectionPoolDS</code> ，实现<code>ConnectionPoolDataSource</code>接口。系统管理员创建此类的实例，设置其属性，并将其注册到JNDI命名服务。Coffee Break已经购买了它的<code>DataSource</code>类<code>com.applogic.PooledDataSource</code> ，来自其EJB服务器供应商Application Logic，Inc。类<code>com.applogic.PooledDataSource</code>通过使用<code>ConnectionPoolDataSource</code>类<code>com.dbaccess.提供的底层支持来实现连接池<code>com.dbaccess.ConnectionPoolDS</code> 。</p>
<p>必须首先部署<code>ConnectionPoolDataSource</code>对象。以下代码创建<code>com.dbaccess.的实例<code>com.dbaccess.ConnectionPoolDS</code>并设置其属性：</p>
<div class="codeblock"><pre>com.dbaccess。ConnectionPoolDS cpds = new com.dbaccess。ConnectionPoolDS（）; cpds.setServerName（ “奶精”）; cpds.setDatabaseName（ “COFFEEBREAK”）; cpds.setPortNumber（9040）; cpds.setDescription（“+”COFFEEBREAK DBMS的连接池“）;</pre></div>
<p>部署<code>ConnectionPoolDataSource</code>对象后，系统管理员将部署<code>DataSource</code>对象。以下代码注册<code>com.dbaccess.ConnectionPoolDS</code>对象<code><em>cpds</em></code>与JNDI命名服务。请注意，与<code><em>cpds</em></code>变量关联的逻辑名称在子上下文<code>jdbc</code>下添加了子上下文<code>pool</code> ，这类似于将子目录添加到分层文件系统中的另一个子目录。<code>com.dbaccess.类的任何实例的逻辑名称<code>com.dbaccess.ConnectionPoolDS</code>将始终以<code>jdbc/pool</code>开头。Oracle建议将所有<code>ConnectionPoolDataSource</code>对象放在子上下文<code>jdbc/pool</code> ：</p>
<div class="codeblock"><pre>Context ctx = new InitialContext（）; ctx.bind（“jdbc / pool / fastCoffeeDB”，cpds）;</pre></div>
<p>接下来，实现的<code>DataSource</code>类与<code><em>cpds</em></code>变量和<code><em>cpds</em></code>其他实例进行<code>com.dbaccess.部署了ConnectionPoolDS</code>类。以下代码创建此类的实例并设置其属性。请注意，此<code>com.applogic.实例仅设置了两个属性<code>com.applogic.PooledDataSource</code> 。设置<code>description</code>属性是因为始终需要它。设置的另一个属性<code>dataSourceName</code>为<code><em>cpds</em></code>提供逻辑JNDI名称，这是<code><em>cpds</em></code>一个实例<code>com.dbaccess.ConnectionPoolDS</code>类。换句话说， <code><em>cpds</em></code>表示将实现<code>DataSource</code>对象的连接池的<code>ConnectionPoolDataSource</code>对象。</p>
<p>以下代码可能由部署工具执行，它创建一个<code>PooledDataSource</code>对象，设置其属性，并将其绑定到逻辑名称<code>jdbc/fastCoffeeDB</code> ：</p>
<div class="codeblock"><pre>com.applogic。PooledDataSource ds = new com.applogic。PooledDataSource（）; ds.setDescription（“产生与COFFEEBREAK的池化连接”）; ds.setDataSourceName（ “JDBC /池/ fastCoffeeDB”）; Context ctx = new InitialContext（）; ctx.bind（“jdbc / fastCoffeeDB”，ds）;</pre></div>
<p>此时，部署了一个<code>DataSource</code>对象，应用程序可以从该对象获得与数据库<code>COFFEEBREAK</code>池连接。</p>
<!-- ************************************ -->
<h2><a name="pooled_connection" id="pooled_connection">获取和使用池连接</a></h2>
<p><em>连接池</em>是数据库连接对象的缓存。对象表示应用程序可用于连接到数据库的物理数据库连接。在运行时，应用程序从池请求连接。如果池包含可满足请求的连接，则返回与应用程序的连接。如果未找到任何连接，则会创建新连接并将其返回给应用程序。应用程序使用连接对数据库执行某些操作，然后将对象返回池。然后，该连接可用于下一个连接请求。</p>
<p>连接池可以促进连接对象的重用，并减少创建连接对象的次数。连接池显着提高了数据库密集型应用程序的性能，因为创建连接对象在时间和资源方面都很昂贵。</p>
<p>现在已经部署了这些<code>DataSource</code>和<code>ConnectionPoolDataSource</code>对象，程序员可以使用<code>DataSource</code>对象来获得池化连接。获取池连接的代码就像获取非池连接的代码一样，如以下两行所示：</p>
<div class="codeblock"><pre>ctx = new InitialContext（）; ds =（DataSource）ctx.lookup（“jdbc / fastCoffeeDB”）;</pre></div>
<p>变量<code><em>ds</em></code>表示<code>DataSource</code>对象，该对象生成与数据库<code>COFFEEBREAK</code>池连接。您只需要检索一次此<code>DataSource</code>对象，因为您可以根据需要使用它来生成任意数量的池连接。在<code><em>ds</em></code>变量上调用<code>getConnection</code>方法会自动生成池连接，因为<code><em>ds</em></code>变量表示的<code>DataSource</code>对象被配置为生成池连接。</p>
<p>连接池通常对程序员是透明的。使用池化连接时，只需要执行两项操作：</p>
<ol>
<li>
<p>使用<code>DataSource</code>对象而不是<code>DriverManager</code>类来获取连接。在以下代码行中， <code><em>ds</em></code>是一个实现和部署的<code>DataSource</code>对象，因此它将创建池化连接， <code>username</code>和<code>password</code>是表示有权访问数据库的用户凭据的变量：</p>
<div class="codeblock"><pre>Connection con = ds.getConnection（用户名，密码）;</pre></div>
</li>
<li>
<p>使用<code>finally</code>语句关闭池连接。在应用于使用池化连接的代码的<code>try/catch</code>块之后，将出现以下<code>finally</code>块：</p>
<div class="codeblock"><pre>尝试{Connection con = ds.getConnection（username，password）; // ...使用池化//连接con} catch的代码（Exception ex {// ...代码来处理异常}最终{if（con！）= null）con.close（）; }</pre></div>
</li>
</ol>
<p>否则，使用池连接的应用程序与使用常规连接的应用程序相同。应用程序员在完成连接池时可能会注意到的另一件事是性能更好。</p>
<p>以下示例代码获取一个<code>DataSource</code>对象，该对象生成与数据库<code>COFFEEBREAK</code>连接，并使用它来更新表<code>COFFEES</code>的价格：</p>
<div class="codeblock"><pre>import java.sql。*; import javax.sql。*; import javax.ejb。*; import javax.naming。*;公共类ConnectionPoolingBean实现SessionBean {// ...public void ejbCreate（）抛出CreateException {ctx = new InitialContext（）; ds =（DataSource）ctx.lookup（“jdbc / fastCoffeeDB”）; public void updatePrice（float price，String cofName，String username，String password）抛出SQLException {Connection con; PreparedStatement pstmt; try {con = ds.getConnection（username，password）; con.setAutoCommit（假）; pstmt = con.prepareStatement（“UPDATE COFFEES”+“SET PRICE =？“+”在哪里COF_NAME =？“）; pstmt.setFloat（1，price）; pstmt.setString（2，cofName）; pstmt.executeUpdate（）; con.commit（）; pstmt.close（）;} finally {if（con！）= null）con.close（）; private DataSource ds = null; private Context ctx = null; }</pre></div>
<p>此代码示例中的连接参与连接池，因为以下情况属实：</p>
<ul>
<li>已部署实现<code>ConnectionPoolDataSource</code>的类的实例。</li>
<li>已部署实现<code>DataSource</code>的类的实例，并且其<code>dataSourceName</code>属性的值集是绑定到先前部署的<code>ConnectionPoolDataSource</code>对象的逻辑名。</li>
</ul>
<p>请注意，尽管此代码与您之前看到的代码非常相似，但它在以下方面有所不同：</p>
<ul>
<li>
<p>除<code>java.sql</code>外，它还导入<code>javax.sql</code> ， <code>javax.ejb</code>和<code>javax.naming</code>包。</p>
<p><code>DataSource</code>和<code>ConnectionPoolDataSource</code>接口位于<code>javax.sql</code>包中，JNDI构造函数<code>InitialContext</code>和方法<code>Context.lookup</code>是<code>javax.naming</code>包的一部分。此特定示例代码采用EJB组件的形式，该组件使用<code>javax.ejb</code>包中的API。此示例的目的是显示您使用池化连接的方式与使用非池化连接的方式相同，因此您无需担心理解EJB API。</p>
</li>
<li>
<p>它使用<code>DataSource</code>对象来获取连接，而不是使用<code>DriverManager</code>工具。</p>
</li>
<li>
<p>它使用<code>finally</code>块来确保连接已关闭。</p>
</li>
</ul>
<p>获取和使用池化连接类似于获取和使用常规连接。当充当系统管理员的人正确部署了<code>ConnectionPoolDataSource</code>对象和<code>DataSource</code>对象时，应用程序使用该<code>DataSource</code>对象来获取池连接。但是，应用程序应使用<code>finally</code>块来关闭池化连接。为简单起见，前面的示例使用了<code>finally</code>块但没有使用<code>catch</code>块。如果<code>try</code>块中的方法抛出异常，则默认情况下将抛出该异常，并且在任何情况下都将执行<code>finally</code>子句。</p>
<!-- ************************************ -->
<h2><a name="deployment_distributed_transactions" id="deployment_distributed_transactions">部署分布式事务</a></h2>
<p>可以部署<code>DataSource</code>对象以获取可在分布式事务中使用的连接。与连接池一样，必须部署两个不同的类实例： <code>XADataSource</code>对象和实现与之一起使用的<code>DataSource</code>对象。</p>
<p>假设The Coffee Break企业家购买的EJB服务器包含<code>DataSource</code>类<code>com.applogic.TransactionalDS</code> ，适用于<code>com.dbaccess.等<code>XADataSource</code>类<code>com.dbaccess.XATransactionalDS</code> 。它适用于任何<code>XADataSource</code>类的事实使EJB服务器可以跨JDBC驱动程序移植。部署<code>DataSource</code>和<code>XADataSource</code>对象时，生成的连接将能够参与分布式事务。在这种情况下，类<code>com.applogic.实现TransactionalDS</code> ，以便生成的连接也是池连接，这通常是作为EJB服务器实现的一部分提供的<code>DataSource</code>类的情况。</p>
<p>必须首先部署<code>XADataSource</code>对象。以下代码创建<code>com.dbaccess.的实例<code>com.dbaccess.XATransactionalDS</code>并设置其属性：</p>
<div class="codeblock"><pre>com.dbaccess。XATransactionalDS xads = new com.dbaccess。XATransactionalDS（）; xads.setServerName（ “奶精”）; xads.setDatabaseName（ “COFFEEBREAK”）; xads.setPortNumber（9040）; xads.setDescription（“COFFEEBREAK DBMS的分布式事务”）;</pre></div>
<p>以下代码注册<code>com.dbaccess.XATransactionalDS</code>使用JNDI命名服务对象<code><em>xads</em></code> 。请注意，与<code><em>xads</em></code>关联的逻辑名称在<code>jdbc</code>下添加了子上下文<code>xa</code> 。Oracle建议使用<code>com.dbaccess.类的任何实例的逻辑名称<code>com.dbaccess.XATransactionalDS</code>始终以<code>jdbc/xa</code>开头。</p>
<div class="codeblock"><pre>Context ctx = new InitialContext（）; ctx.bind（“jdbc / xa / distCoffeeDB”，xads）;</pre></div>
<p>接下来，部署实现与<code><em>xads</em></code>和其他<code>XADataSource</code>对象交互的<code>DataSource</code>对象。注意<code>DataSource</code>类<code>com.applogic.TransactionalDS</code>可以与任何JDBC驱动程序供应商的<code>XADataSource</code>类一起使用。部署<code>DataSource</code>对象涉及创建<code>com.applogic.的实例<code>com.applogic.TransactionalDS</code>类并设置其属性。<code>dataSourceName</code>属性设置为<code>jdbc/xa/distCoffeeDB</code> ，与<code>com.dbaccess.关联的逻辑名称<code>com.dbaccess.XATransactionalDS</code> 。这是<code>XADataSource</code>类，它实现<code>DataSource</code>类的分布式事务功能。以下代码部署<code>DataSource</code>类的实例：</p>
<div class="codeblock"><pre>com.applogic。TransactionalDS ds = new com.applogic。TransactionalDS（）; ds.setDescription（“生成分布式事务”+“与COFFEEBREAK的连接”）; ds.setDataSourceName（ “JDBC / XA / distCoffeeDB”）; Context ctx = new InitialContext（）; ctx.bind（“jdbc / distCoffeeDB”，ds）;</pre></div>
<p>现在<code>com.applogic.类的实例<code>com.applogic.TransactionalDS</code>和<code>com.dbaccess.已经部署了XATransactionalDS</code> ，应用程序可以在<code>TransactionalDS</code>类的实例上调用方法<code>getConnection</code> ，以获得可以在分布式事务中使用的<code>COFFEEBREAK</code>数据库的连接。</p>
<!-- ************************************ -->
<h2><a name="using_connections_distributed_transactions" id="using_connections_distributed_transactions">使用分布式事务的连接</a></h2>
<p>要获得可用于分布式事务的连接，必须使用已正确实现和部署的<code>DataSource</code>对象，如“ <a href="#deployment_distributed_transactions">部署分布式事务</a> ”一节中所示。使用这样的<code>DataSource</code>对象，在其上调用方法<code>getConnection</code> 。连接后，使用它就像使用任何其他连接一样。由于<code>jdbc/distCoffeesDB</code>已与JNDI命名服务中的<code>XADataSource</code>对象关联，因此以下代码生成可在分布式事务中使用的<code>Connection</code>对象：</p>
<div class="codeblock"><pre>Context ctx = new InitialContext（）; DataSource ds =（DataSource）ctx.lookup（“jdbc / distCoffeesDB”）; Connection con = ds.getConnection（）;</pre></div>
<p>当它是分布式事务的一部分时，对如何使用此连接存在一些次要但重要的限制。事务管理器控制分布式事务何时开始以及何时提交或回滚;因此，应用程序代码永远不应该调用<code>Connection.commit</code>或<code>Connection.rollback</code>方法。应用程序同样应该永远不会调用<code>Connection.setAutoCommit(true)</code> ，它启用自动提交模式，因为这也会干扰事务管理器对事务边界的控制。这解释了为什么在分布式事务范围内创建的新连接默认情况下禁用其自动提交模式。请注意，这些限制仅适用于连接参与分布式事务的情况;连接不是分布式事务的一部分时没有限制。</p>
<p>对于以下示例，假设已发送咖啡订单，这会触发对位于不同DBMS服务器上的两个表的更新。第一个表是新的<code>INVENTORY</code>表，第二个表是<code>COFFEES</code>表。由于这些表位于不同的DBMS服务器上，因此涉及它们的事务将是分布式事务。以下示例中的代码获取连接，更新<code>COFFEES</code>表并关闭连接，是分布式事务的第二部分。</p>
<p>请注意，代码不会显式提交或回滚更新，因为分布式事务的范围由中间层服务器的底层系统基础结构控制。此外，假设用于分布式事务的连接是池连接，应用程序使用<code>finally</code>块来关闭连接。这可确保即使抛出异常也将关闭有效连接，从而确保将连接返回到连接池以进行回收。</p>
<p>以下代码示例演示了企业Bean，它是一个实现客户端计算机可以调用的方法的类。此示例的目的是演示分布式事务的应用程序代码与其他代码没有区别，只是它不调用<code>Connection</code>方法<code>commit</code> ， <code>rollback</code>或<code>setAutoCommit(true)</code> 。因此，您无需担心了解所使用的EJB API。</p>
<div class="codeblock"><pre>import java.sql。*; import javax.sql。*; import javax.ejb。*; import javax.naming。*;公共类DistributedTransactionBean实现SessionBean {// ...public void ejbCreate（）抛出CreateException {ctx = new InitialContext（）; ds =（DataSource）ctx.lookup（“jdbc / distCoffeesDB”）; public void updateTotal（int incr，String cofName，String username，String password）抛出SQLException {Connection con; PreparedStatement pstmt; try {con = ds.getConnection（username，password）; pstmt = con.prepareStatement（“UPDATE COFFEES”+“SET TOTAL = TOTAL +？“+”在哪里COF_NAME =？“）; pstmt.setInt（1，incr）; pstmt.setString（2，cofName）; pstmt.executeUpdate（）; stmt.close（）;} finally {if（con！）= null）con.close（）; private DataSource ds = null; private Context ctx = null; }</pre></div>


        </div>
        <div class="NavBit">
            <a href="connecting.html" target="_top">«上一页</a> • <a href="../TOC.html" target="_top">小道</a> • <a href="sqlexception.html" target="_top">下一页»</a>
        </div>
    </div>
    
<hr class="clearfloat">

<div id="Footer">

<p class="footertext">
<a href="http://www.oracle.com/corporate/index.html">关于Oracle</a> | <a href="http://www.oracle.com/us/corporate/contact/index.html">联系我们</a> | <a href="http://www.oracle.com/us/legal/index.html">法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href="http://www.oracle.com/us/legal/privacy/index.html">您的隐私权</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&amp;id=en-US">版权所有©1995,2017 Oracle和/或其附属公司。版权所有。</a></p>
       
</div>    
    <div class="PrintHeaders">
        <b>上一页：</b>建立连接<br><b>下一页：</b>处理SQLExceptions</div>
<!-- Start SiteCatalyst code -->
<script type="application/javascript" src="https://www.oracleimg.com/us/assets/metrics/ora_docs.js"></script>
<!-- End SiteCatalyst code --> 
</body>
</html>