<html lang="en-US" dir="ltr" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>课程：JDBC简介（Java™教程&gt; JDBC（TM）数据库访问）</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
     <meta name="description" content="This JDBC Java tutorial describes how to use JDBC API to create, insert into, update, and query tables. You will also learn how to use simple and prepared statements, stored procedures and perform transactions"></meta>
     <meta name="keywords" content="java programming, learn java, java sample code, jdbc, prepared statement, result set"></meta>
        
<style type="text/css">body {
  margin-left: 10px;
  margin-right: 10px;
  line-height: 1.5;
  FONT-FAMILY: Arial,Helvetica,sans-serif;
  font-size: 0.8em;
}
a:link {
  text-decoration: none;
  color: #09569d;
}
a:visited {
  text-decoration: none;
  color: #3a87cf;
}
a:hover {
  text-decoration: underline;
}
code {
  font-family: Monaco,Courier,"Courier New";
}
.header-container {
  background-color: #fff;
  border-bottom: 1px solid #c1cfda;
  -webkit-box-shadow: 0 2px 2px rgba(117,163,231,0.1);
  box-shadow: 0 2px 2px rgba(117,163,231,0.1);
}
.bookwrapper {
  width: auto;
  margin: auto;
}
.clearfix {
}
.clearfloat {
  clear: both;
  overflow: auto;
  height: 0px;
  font-size: 1px;
  line-height: 0px;
}
#brandProdName {
  width: auto;
  height: auto;
}
#logocover {
  display: block;
  background: transparent url('../../images/oracle-java-logo.png') 0px 0px no-repeat;
  height: 50px;
  width: 229px;
  float: left;
}
#productName {
  font-size: 16px;
  position: relative;
  top: 19px;
  padding-left: 3px;
  color: #457798;
  white-space: nowrap;
  width: 340px;
}
.FigureCaption {
  font-family: sans-serif;
  text-align: center;
}
#TopBar_bl {
  width: 100%;
  height: 60px;
}
#TopBar_br {
  width: 100%;
  height: 60px;
}
#TopBar_tl {
  margin-left: -110px;
  margin-right: -100px;
  align: left;
  height: 60px;
}
#TopBar_tr {
  width: 100%;
  height: 60px;
}
#TopBar {
  min-width: 700px;
  padding: 25px 100px 10px;
  margin-bottom: 25px;
  clear: both;
  border-bottom: 1px solid #d2dde5;
  border-radius: 3px;
  background: #efefef;
  /* Old browsers */
  /* IE9 SVG, needs conditional override of 'filter' to 'none' */
  
  background: -moz-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* FF3.6+ */
  background: -webkit-gradient(linear,left top,left bottom,color-stop(0%,#ffffff),color-stop(100%,#e2eff9));
  /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* Opera 11.10+ */
  background: -ms-linear-gradient(top,#ffffff 0%,#e2eff9 100%);
  /* IE10+ */
  background: linear-gradient(to bottom,#ffffff 0%,#e2eff9 100%);
  /* W3C */
  /* IE6-8 */
}
#TopBar_left {
  line-height: 14px;
  position: absolute;
  padding-top: 30px;
  padding-right: 30px;
  padding-left: 30px;
  text-align: left;
  font: 13px/20px Arial,Helvetica,sans-serif;
  font-weight: bold;
  font-size: 20px;
  color: #333;
}
#TopBar_right {
  line-height: 12px;
  float: right;
  padding-top: 10px;
  padding-right: 30px;
  text-align: left;
}
@media print {
  #BreadCrumbs, #Download {
    display: none;
  }
}
@media print {
  #TopBar_right {
    display: none;
  }
}
#TopBar_right a {
  font-size: 10px;
  margin: 3px;
  padding: 0;
}
#BreadCrumbs {
  padding: 15px 5px 0.5em 0;
  font-family: sans-serif;
  float: right;
}
#BreadCrumbs a {
  color: #09569d;
}
#BreadCrumbs a:visited, #BreadCrumbs a:link {
  text-decoration: none;
}
#BreadCrumbs a:hover, #BreadCrumbs a:active {
  text-decoration: underline;
}
#PageTitle {
  margin: 0 5px 0.5em 0;
  color: #f90000;
}
#PageContent {
  margin: 0 5px 0 20px;
}
.LeftBar_shown {
  width: 13em;
  float: left;
}
@media print {
  .LeftBar_shown {
    display: none;
  }
}
.LeftBar_hidden {
  display: none;
}
#Footer {
  padding-top: 10px;
  padding-left: 10px;
  margin-right: 10px;
}
.footertext {
  font-size: 10px;
  font-family: sans-serif;
  margin-top: 1px;
}
.NavBit {
  padding: 15px 5px 0.5em 0;
  font-family: sans-serif;
}
@media print {
  .NavBit {
    display: none;
  }
}
#TagNotes {
  text-align: right;
}
@media print {
  #TagNotes a:visited, #TagNotes a:link {
    color: #35556b;
    text-decoration: none;
  }
}
#Contents a, .NavBit a, #TagNotes a {
  color: #09569d;
}
#TagNotes a:visited, #TagNotes a:link, #Contents a:visited, #Contents a:link, .NavBit a:visited, .NavBit a:link {
  text-decoration: none;
}
#TagNotes a:hover, #TagNotes a:active, #Contents a:hover, #Contents a:active, .NavBit a:hover, .NavBit a:active {
  text-decoration: underline;
}
#Contents {
  float: left;
  font-family: sans-serif;
}
@media print {
  #Contents {
    display: none;
  }
}
@media screen {
  div.PrintHeaders {
    display: none;
  }
}
.linkLESSON, .nolinkLESSON {
  margin-left: 0.5em;
  text-indent: -0.5em;
}
.linkAHEAD, .nolinkAHEAD, .linkQUESTIONS, .nolinkQUESTIONS {
  margin-left: 1.5em;
  text-indent: -0.5em;
}
.linkBHEAD, .nolinkBHEAD {
  margin-left: 2.5em;
  text-indent: -0.5em;
}
.linkCHEAD, .nolinkCHEAD {
  margin-left: 3.5em;
  text-indent: -0.5em;
}
.nolinkLESSON, .nolinkAHEAD, .nolinkBHEAD, .nolinkCHEAD, .nolinkQUESTIONS {
  font-weight: bold;
  color: #333;
}
.MainFlow_indented {
  margin-right: 10px;
  margin-left: 15em;
  margin-bottom: 2em;
}
.MainFlow_wide {
  margin-right: 10px;
  margin-left: 10px;
  margin-bottom: 2em;
}
@media print {
  .MainFlow_indented, .MainFlow_wide {
    padding-top: 0;
    margin-top: 10px;
    margin-right: 10px;
    margin-left: 0;
  }
}
h1, h2, h3, h4, h5 {
  color: #333;
}
h1 {
  font-weight: bold;
  font-size: 20px;
}
h2 {
  font-weight: bold;
  font-size: 17px;
}
h3 {
  font-weight: bold;
  font-size: 14px;
}
h4 {
  font-size: 15px;
}
h5 {
  font-size: 12px;
}
#ToggleLeft {
  display: none;
}
.note {
  margin: 0 30px 0px 30px;
}
.codeblock {
  margin: 0 30px 0px 30px;
  font-size: 12px;
  font-family: Monaco,Courier,"Courier New";
}
.tocli {
  list-style-type: none;
}
.betadraft {
  color: red;
}
</style>
<script type="text/javascript">
/* <![CDATA[ */
    function leftBar() {
        var nameq = 'tutorial_showLeftBar='
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookieString = cookies[i];
            while (cookieString.charAt(0) == ' ') {
                cookieString = cookieString.substring(1, cookieString.length);
            }
            if (cookieString.indexOf(nameq) == 0) {
                cookieValue =  cookieString.substring(nameq.length,
                        cookieString.length);
                return cookieValue == 'yes';
            }
        }
        return true;
    }

    function showLeft(b) {
        var contents = document.getElementById("LeftBar");
        var main = document.getElementById("MainFlow");
        var toggle = document.getElementById("ToggleLeft");
        if (b) {
            contents.className = "LeftBar_shown";
            main.className = "MainFlow_indented";
            toggle.innerHTML = "Hide TOC";
            document.cookie = 'tutorial_showLeftBar=yes; path=/';
        } else {
            contents.className = "LeftBar_hidden";
            main.className = "MainFlow_wide";
            toggle.innerHTML = "Show the TOC";
            document.cookie = 'tutorial_showLeftBar=no; path=/';
        }
    }

    function toggleLeft() {
        showLeft(document.getElementById("LeftBar").className ==
                "LeftBar_hidden");
        document.getElementById("ToggleLeft").blur();
    }

    function load() {
        showLeft(leftBar());
        document.getElementById("ToggleLeft").style.display="inline";
    }

    function showCode(displayCodePage, codePath) {
        var codePathEls = codePath.split("/");
        var currDocPathEls = location.href.split("/");
        //alert ("codePathEls = " + codePathEls + "n" + "currDocPathEls = " + currDocPathEls);
        currDocPathEls.pop(); // remove file name at the end
        while (codePathEls.length > 0) {
            if (codePathEls[0] == "..") {
                codePathEls.shift();
                currDocPathEls.pop();
            } else {
                break;
            }
        }
        var fullCodePath = currDocPathEls.join("/") + "/" + codePathEls.join("/");
        //alert ("fullCodePath = " + fullCodePath );
        if (codePath.indexOf(".java") != -1 || codePath.indexOf(".jnlp") != -1) {
            window.location.href = displayCodePage + "?code=" + encodeURI(fullCodePath);
        } else {
            window.location.href = fullCodePath;
        }
    }
/* ]]> */    
</script>


    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
<body dir="ltr" onload="load()">
    <noscript>启用了JavaScript的浏览器需要此页面正常运行。
    </noscript>
    <!-- ixheader -->
    <div class="header-container">
        <div class="bookwrapper  clearfix">       
            <div id="brandProdName">
                <div id="logocover"></div>
                <div id="productName">文档</div>
            </div> 
            <br class="clearfloat">
        </div>
    </div>
    
    <div id="TopBar">
        <div id="TopBar_tr"> <div id="TopBar_tl"> <div id="TopBar_br"> <div id="TopBar_bl"> 
                    <div id="TopBar_left">Java™教程</div>
                    <div id="TopBar_right"> 
                        <a href="javascript:void(0);" id="ToggleLeft">隐藏TOC</a>
                    </div> 
      </div> </div> </div> </div> </div>

    <div id="LeftBar" class="LeftBar_shown">
        <div id="Contents">
            <div class="nolinkLESSON">JDBC简介</div>
<div class="linkAHEAD"><a href="architecture.html">JDBC架构</a></div>
<div class="linkAHEAD"><a href="database.html">关系数据库概述</a></div>
</div>
    </div>
    <div id="MainFlow" class="MainFlow_indented">
        <div class="PrintHeaders">
            <b>Trail：</b> JDBC（TM）数据库访问</div>
        <div id="BreadCrumbs">
            <a href="../../index.html" target="_top">主页</a> &gt; <a href="../index.html" target="_top">JDBC（TM）数据库访问</a>
        </div>
        <div class="NavBit">
                <a href="../index.html" target="_top">«上一页</a> • <a href="../TOC.html" target="_top">小道</a> • <a href="architecture.html" target="_top">下一页»</a>
        </div>
        <div class="Banner"><p style="background-color:rgb(247,248,249);border-width:1px;padding:10px;font-style:italic;border-style:solid;border-color:rgb(64,74,91)">Java教程是为JDK 8编写的。本页中描述的示例和实践未利用后续版本中引入的改进。</p></div>
        <div id="PageTitle"><h1>课程：JDBC简介</h1></div>
        <div id="PageContent">

<p>JDBC API是一种Java API，可以访问任何类型的表格数据，尤其是存储在<a href="#relational">关系数据库中的数据。</a></p>
<p><a name="1007905"></a> JDBC帮助您编写管理这三种编程活动的Java应用程序：</p>
<ol>
<li><a name="1001514"></a>连接到数据源，如数据库</li>
<li><a name="1001493"></a>将查询和更新语句发送到数据库</li>
<li><a name="1001498"></a>检索并处理从数据库接收的结果以回答您的查询</li>
</ol>
<p>以下简单的代码片段给出了这三个步骤的简单示例：</p>
<div class="codeblock"><pre>public void connectToAndQueryDatabase（String username，String password）{Connection con = DriverManager.getConnection（“jdbc：myDriver：myDatabase”，username，password）;语句stmt = con.createStatement（）; ResultSet rs = stmt.executeQuery（“SELECT a，b，c FROM Table1”）; while（rs.next（））{int x = rs.getInt（“a”）; String s = rs.getString（“b”）; float f = rs.getFloat（“c”）; }}</pre></div>
<p>这个短代码片段实例化一个<code>DriverManager</code>对象以连接到数据库驱动程序并登录到数据库，实例化一个带有SQL语言查询的<code>Statement</code>对象到数据库;实例化一个<code>ResultSet</code>对象，该对象检索查询结果，并执行一个简单的<code>while</code>循环，该循环检索并显示这些结果。就这么简单。</p>
<h2>JDBC产品组件</h2>
<p>JDBC包括四个组件：</p>
<ol>
<li>
<p><b>JDBC API</b> -  JDBC™API提供对Java™编程语言的关系数据的编程访问。使用JDBC API，应用程序可以执行SQL语句，检索结果并将更改传播回底层数据源。JDBC API还可以在分布式异构环境中与多个数据源进行交互。</p>
<p>JDBC API是Java平台的一部分，其中包括<i>Java™标准版</i> （Java™SE）和<i>Java™Enterprise Edition</i> （Java™EE）。JDBC 4.0 API分为两个包： <code>java.sql</code>和<code>javax.sql.</code> 这两个包都包含在Java SE和Java EE平台中。</p>
</li>
<li>
<p><b>JDBC驱动程序管理器</b> -  JDBC <code>DriverManager</code>类定义可以将Java应用程序连接到JDBC驱动程序的对象。<code>DriverManager</code>传统上一直是JDBC架构的支柱。它非常小而且简单。</p>
<p>标准扩展包<code>javax.naming</code>和<code>javax.sql</code>允许您使用向<i>Java命名和目录接口</i> （JNDI）命名服务注册的<code>DataSource</code>对象来建立与数据源的连接。您可以使用任一连接机制，但建议尽可能使用<code>DataSource</code>对象。</p>
</li>
<li>
<p><b>JDBC测试套件</b> -  JDBC驱动程序测试套件可帮助您确定JDBC驱动程序将运行您的程序。这些测试并不全面或详尽，但它们确实运用了JDBC API中的许多重要功能。</p>
</li>
<li>
<p><b>JDBC-ODBC Bridge</b> -  Java Software桥通过ODBC驱动程序提供JDBC访问。请注意，您需要将ODBC二进制代码加载到使用此驱动程序的每台客户端计算机上。因此，ODBC驱动程序最适用于客户端安装不是主要问题的企业网络，或者适用于以三层体系结构用Java编写的应用程序服务器代码。</p>
</li>
</ol>
<p>此Trail使用这四个JDBC组件中的前两个连接到数据库，然后构建一个使用SQL命令与测试关系数据库通信的Java程序。最后两个组件在专用环境中用于测试Web应用程序，或与支持ODBC的DBMS进行通信。</p>
<h2>JDBC架构</h2>
<p><a name="teir" id="teir"></a></p>
<h3>两层和三层处理模型</h3>
<p>JDBC API支持用于数据库访问的两层和三层处理模型。</p>
<p><a name="fig1" id="fig1"></a></p>
<p style="font-style:italic;font-weight:bold">图1：数据访问的双层体系结构。</p>
<br>
<p><a name="1012830"></a></p>
<img alt="DBMS专有协议提供客户端计算机和数据库服务器之间的双向通信" src="intro.anc2.gif"><br>
<p>在双层模型中，Java applet或应用程序直接与数据源对话。这需要一个JDBC驱动程序，它可以与正在访问的特定数据源进行通信。用户的命令被传递到数据库或其他数据源，并且这些语句的结果被发送回用户。数据源可以位于用户通过网络连接的另一台机器上。这被称为客户端/服务器配置，用户的机器作为客户端，机器将数据源作为服务器。网络可以是内联网，例如，连接公司内的员工，或者可以是因特网。</p>
<p><a name="1018848"></a>在三层模型中，命令被发送到服务的“中间层”，然后将命令发送到数据源。数据源处理命令并将结果发送回中间层，然后中间层将它们发送给用户。MIS主管发现三层模型非常具有吸引力，因为中间层可以保持对访问的控制以及可以对公司数据进行的更新。另一个优点是它简化了应用程序的部署。最后，在许多情况下，三层架构可以提供性能优势。</p>
<p><a name="fig2" id="fig2"></a></p>
<p style="font-style:italic;font-weight:bold">图2：数据访问的三层体系结构。</p>
<br>
<p><a name="1011843"></a></p>
<img alt="DBMS专有协议提供数据库服务器和服务器机器之间的双向通信。HTTP，RMI，CORBA或其他调用提供服务器计算机和客户端计算机之间的双向通信" src="intro.anc1.gif"><br>
<p><a name="1018844"></a>直到最近，中间层通常用C或C ++等语言编写，这些语言提供了快速的性能。然而，随着优化编译器的引入，将Java字节码转换为高效的机器特定代码和技术，例如Enterprise JavaBeans™，Java平台正迅速成为中间层开发的标准平台。这是一个很大的优势，可以利用Java的健壮性，多线程和安全功能。</p>
<p><a name="1011844"></a>随着企业越来越多地使用Java编程语言编写服务器代码，JDBC API在三层体系结构的中间层中越来越多地被使用。使JDBC成为服务器技术的一些功能是它支持连接池，分布式事务和断开连接的行集。JDBC API也允许从Java中间层访问数据源。</p>
<p><a name="relational" id="relational"></a></p>
<h2>关系数据库概述</h2>
<p>数据库是一种以可以从中检索信息的方式存储信息的方法。简单来说，关系数据库是在包含行和列的表中显示信息的数据库。在某种意义上，表被称为关系，它是相同类型（行）的对象的集合。表中的数据可以根据公共密钥或概念进行关联，并且从表中检索相关数据的能力是术语关系数据库的基础。数据库管理系统（DBMS）处理数据的存储，维护和检索方式。对于关系数据库，关系数据库管理系统（RDBMS）执行这些任务。本书中使用的DBMS是包含RDBMS的通用术语。</p>
<p><a name="integrity" id="integrity"></a></p>
<h3>诚信规则</h3>

<p>关系表遵循某些完整性规则，以确保它们包含的数据保持准确并始终可访问。首先，关系表中的行应该都是不同的。如果存在重复行，则可能存在解决两个可能选择中哪一个是正确选择的问题。对于大多数DBMS，用户可以指定不允许重复行，如果这样做，DBMS将阻止添加任何复制现有行的行。</p>

<p>传统关系模型的第二个完整性规则是列值不能是重复组或数组。数据完整性的第三方面涉及空值的概念。数据库通过使用空值来指示缺少值，从而处理数据可能不可用的情况。它不等于空白或零。空白被认为等于另一个空白，零等于另一个零，但两个空值不被视为相等。</p>

<p>当表中的每一行不同时，可以使用一列或多列来标识特定行。此唯一列或列组称为主键。作为主键一部分的任何列都不能为空;如果是，则包含它的主键将不再是完整的标识符。此规则称为实体完整性。</p>

<p><code>Employees</code>表说明了其中一些关系数据库概念。它有五列六行，每行代表一个不同的员工。</p>
<p><a name="employees" id="employees"></a></p>
<p class="center"><code>Employees</code>表</p>
<table border="1" summary="Employees, sample database table">
<tr>
<th><code>员工编号</code></th>
<th><code>名字</code></th>
<th><code>姓</code></th>
<th><code>出生日期</code></th>
<th><code>Car_Number</code></th>
</tr>
<tr>
<td>10001</td>
<td>阿克塞尔</td>
<td>华盛顿</td>
<td>28  -  8  -  43</td>
<td>五</td>
</tr>
<tr>
<td>10083</td>
<td>阿维德</td>
<td>夏尔马</td>
<td>24-NOV-54</td>
<td>空值</td>
</tr>
<tr>
<td>10120</td>
<td>乔纳斯</td>
<td>金斯伯格</td>
<td>01-JAN-69</td>
<td>空值</td>
</tr>
<tr>
<td>10005</td>
<td>佛罗伦萨</td>
<td>Wojokowski</td>
<td>04  -  07月71</td>
<td>12</td>
</tr>
<tr>
<td>10099</td>
<td>肖恩</td>
<td>华盛顿</td>
<td>09月21日66</td>
<td>空值</td>
</tr>
<tr>
<td>10035</td>
<td>伊丽莎白</td>
<td>山口</td>
<td>24日 -  12月59</td>
<td>空值</td>
</tr>
</table>
<p>该表的主键通常是员工编号，因为每个人都保证不同。（对于进行比较，数字也比字符串更有效。）也可以使用<code>First_Name</code>和<code>Last_Name</code>因为两者的组合也只能识别我们的示例数据库中的一行。单独使用姓氏是行不通的，因为有两名员工的姓氏为“华盛顿”。在这种特殊情况下，名字都是不同的，因此可以想象使用该列作为主键，但最好避免使用可能发生重复的列。如果Elizabeth Yamaguchi在这家公司工作并且主键是<code>First_Name</code> ，则RDBMS将不允许添加她的名字（如果已经指定不允许重复）。因为表中已经有一个Elizabeth，所以添加第二个会使主键无法用作识别一行的方法。请注意，尽管使用<code>First_Name</code>和<code>Last_Name</code>是此示例的唯一组合键，但它在较大的数据库中可能不是唯一的。另请注意， <code>Employee</code>表假定每个员工只能有一辆车。</p>


<h3><a name="select" id="select"><code>SELECT</code>语句</a></h3>
<p>SQL是一种旨在与关系数据库一起使用的语言。有一组基本的SQL命令被认为是标准的，并且被所有RDBMS使用。例如，所有RDBMS都使用<code>SELECT</code>语句。</p>
<p><code>SELECT</code>语句（也称为查询）用于从表中获取信息。它指定一个或多个列标题，一个或多个要从中选择的表，以及一些选择标准。RDBMS返回满足所述要求的列条目的行。<code>SELECT</code>语句（如下所示）将获取拥有公司汽车的员工的名字和姓氏：</p>

<div class="codeblock"><pre>SELECT First_Name，Last_Name FROM Employees WHERE Car_Number IS NOT NULL</pre></div>

<p>下面是结果集（满足<code>Car_Number</code>列中不具有null的要求的行集）。为满足要求的每一行打印名字和姓氏，因为<code>SELECT</code>语句（第一行）指定了<code>First_Name</code>和<code>Last_Name</code>列。<code>FROM</code>子句（第二行）给出了将从中选择列的表。</p>

<table border="1" summary="Result set of not having null in the Car_Number column">

<tr>
<th>名字</th>
<th>姓</th>
</tr>

<tr>
<td>阿克塞尔</td>
<td>华盛顿</td>
</tr>

<tr>
<td>佛罗伦萨</td>
<td>Wojokowski</td>
</tr>

</table>



<p>下面的代码生成一个包含整个表的结果集，因为它要求表没有限制的Employees中的所有列（没有<code>WHERE</code>子句）。请注意， <code>SELECT *</code>表示“SELECT all columns”。</p>
<div class="codeblock"><pre>SELECT * FROM Employees</pre></div>
<p><a name="where" id="where"></a></p>
<h3><code>WHERE</code>条款</h3>
<p><code>SELECT</code>语句中的<code>WHERE</code>子句提供了选择值的条件。例如，在以下代码片段中，仅当值出现在Last_Name列以字符串“Washington”开头的行中时，才会选择值。</p>
<div class="codeblock"><pre>SELECT First_Name，Last_Name FROM Employees WHERE Last_Name LIKE'Washington％'</pre></div>
<p>关键字<code>LIKE</code>用于比较字符串，它提供了可以使用包含通配符的模式的功能。例如，在上面的代码片段中，'Washington'末尾有一个百分号（ <code>%</code> ），表示包含字符串'Washington'和零个或多个附加字符的任何值都将满足此选择条件。所以'华盛顿'或'华盛顿'将是比赛，但'洗'不会。<code>LIKE</code>子句中使用的另一个通配符是下划线（ <code>_</code> ），表示任何一个字符。例如，</p>
<div class="codeblock"><pre>WHERE Last_Name LIKE'Ba_man'</pre></div>
<p>会匹配'蝙蝠侠'，'巴曼'，'巴德曼'，'巴尔曼'，'巴格曼'，'巴曼'等等。</p>
<p>下面的代码片段有一个<code>WHERE</code>子句，它使用等号（=）来比较数字。它选择分配了汽车12的员工的名字和姓氏。</p>
<div class="codeblock"><pre>SELECT First_Name，Last_Name FROM Employees WHERE Car_Number = 12</pre></div>
<p>下一个代码片段选择员工编号大于10005的员工的名字和姓氏：</p>
<div class="codeblock"><pre>SELECT First_Name，Last_Name FROM Employees WHERE Employee_Number&gt; 10005</pre></div>
<p><code>WHERE</code>子句可以在多个条件下得到相当复杂的，在某些DBMS中，嵌套条件也是如此。本概述不会涵盖复杂的<code>WHERE</code>子句，但以下代码片段具有带有两个条件的<code>WHERE</code>子句;此查询选择员工编号小于10100且没有公司汽车的员工的名字和姓氏。</p>
<div class="codeblock"><pre>SELECT First_Name，Last_Name FROM Employees WHERE Employee_Number &lt;10100和Car_Number为NULL</pre></div>
<p>特殊类型的<code>WHERE</code>子句涉及连接，这将在下一节中介绍。</p>
<p><a name="joins" id="joins"></a></p>
<h3>加盟</h3>
<p>关系数据库的一个显着特征是可以从所谓的连接中的多个表中获取数据。假设在检索拥有公司汽车的员工的姓名后，人们想知道谁拥有哪辆汽车，包括汽车的品牌，型号和年份。此信息存储在另一个表中， <code>Cars</code> ：</p>
<p><a name="cars" id="cars"></a></p>
<p class="center"><code>Cars</code>表</p>
<table border="1" summary="Cars table">
<tr>
<th><code>Car_Number</code></th>
<th><code>使</code></th>
<th><code>模型</code></th>
<th><code>年</code></th>
</tr>
<tr>
<td>五</td>
<td>本田</td>
<td>思域DX</td>
<td>1996年</td>
</tr>
<tr>
<td>12</td>
<td>丰田</td>
<td>花冠</td>
<td>1999年</td>
</tr>
</table>
<p>两个表中必须有一列才能将它们相互关联。此列必须是一个表中的主键，在另一个表中称为外键。在这种情况下，出现在两个表中的列是<code>Car_Number</code> ，它是表<code>Cars</code>的主键和表Employees中的外键。如果1996年本田思域被破坏并从<code>Cars</code>表中删除，那么<code>Car_Number</code> 5也必须从Employees表中删除，以维持所谓的参照完整性。否则， <code>Employees</code>表中的外键列（ <code>Car_Number</code> ）将包含一个未引用<code>Cars</code>任何内容的条目。外键必须为null或等于它所引用的表的现有主键值。这与主键不同，主键可能不为空。<code>Employees</code>表中的<code>Car_Number</code>列中有多个空值，因为员工可能没有公司汽车。</p>

<p>以下代码询问拥有公司汽车的员工的名字和姓氏，以及这些汽车的品牌，型号和年份。请注意， <code>FROM</code>子句列出了Employees和Cars，因为请求的数据包含在两个表中。在列名称前使用表名和点（。）表示哪个表包含该列。</p>
<div class="codeblock"><pre>选择员工。First_Name，员工。Last_Name，汽车。制造，汽车。模型，汽车。员工年份，汽车员工人数。Car_Number =汽车。Car_Number</pre></div>
<p>这将返回一个类似于以下内容的结果集：</p>


<table border="1" summary="Result set of first and last names of employees who have company cars and for the make, model, and year of those cars">

<tr>
<th><code>名字</code></th>
<th><code>姓</code></th>
<th><code>使</code></th>
<th><code>模型</code></th>
<th><code>年</code></th>
</tr>

<tr>
<td>阿克塞尔</td>
<td>华盛顿</td>
<td>本田</td>
<td>思域DX</td>
<td>1996年</td>
</tr>

<tr>
<td>佛罗伦萨</td>
<td>Wojokowski</td>
<td>丰田</td>
<td>花冠</td>
<td>1999年</td>
</tr>

</table>

<p><a name="commands" id="commands"></a></p>
<h3>常用SQL命令</h3>
<p>SQL命令分为几类，两类主要是数据操作语言（DML）命令和数据定义语言（DDL）命令。DML命令处理数据，检索或修改数据以使其保持最新。DDL命令创建或更改表和其他数据库对象，例如视图和索引。</p>
<p>以下列出了更常见的DML命令：</p>
<ul>
<li>
<p><code>SELECT —</code>用于查询和显示数据库中的数据。<code>SELECT</code>语句指定要包含在结果集中的列。应用程序中使用的绝大多数SQL命令都是<code>SELECT</code>语句。</p>
</li>
<li>
<p><code>INSERT —</code>向表中添加新行。<code>INSERT</code>用于填充新创建的表或向已存在的表添加新行（或行）。</p>
</li>
<li>
<p><code>DELETE —</code>从表中删除指定的行或行集</p>
</li>
<li>
<p><code>UPDATE —</code>更改表中列或列组中的现有值</p>
</li>
</ul>
<p>更常见的DDL命令如下：</p>
<ul>
<li>
<p><code>CREATE TABLE —</code>使用用户提供的列名创建一个表。用户还需要为每列中的数据指定类型。数据类型因RDBMS而异，因此用户可能需要使用元数据来建立特定数据库使用的数据类型。<code>CREATE TABLE</code>通常比数据操作命令使用频率低，因为表只创建一次，而添加或删除行或更改单个值通常更频繁地发生。</p>
</li>
<li>
<p><code>DROP TABLE —</code>删除所有行并从数据库中删除表定义。需要JDBC API实现来支持SQL92，Transitional Level指定的<code>DROP TABLE</code>命令。但是，对<code>DROP TABLE</code>的<code>CASCADE</code>和<code>RESTRICT</code>选项的支持是可选的。此外，当定义了引用要删除的表的视图或完整性约束时， <code>DROP TABLE</code>的行为是实现定义的。</p>
</li>
<li>
<p><code>ALTER TABLE —</code>从表中添加或删除列。它还添加或删除表约束并更改列属性</p>
</li>
</ul>
<p><a name="result" id="result"></a></p>
<h3>结果集和游标</h3>
<p>满足查询条件的行称为结果集。结果集中返回的行数可以是零，一个或多个。用户可以一次访问结果集中的数据，并且游标提供了执行此操作的方法。可以将游标视为指向包含结果集行的文件的指针，并且该指针能够跟踪当前正在访问哪一行。游标允许用户从上到下处理结果集的每一行，因此可以用于迭代处理。生成结果集时，大多数DBMS会自动创建游标。</p>
<p>早期的JDBC API版本为结果集的游标添加了新功能，允许它向前和向后移动，并允许它移动到指定的行或位置相对于另一行的行。</p>
<p><a name="transactions" id="transactions"></a></p>
<h3>交易</h3>
<p>当一个用户访问数据库中的数据时，另一个用户可能同时访问相同的数据。例如，如果第一个用户正在同时更新表中的某些列，而第二个用户正在从同一个表中选择列，则第二个用户可能获得部分旧数据和部分更新数据。因此，DBMS使用事务来保持数据处于一致状态（数据一致性），同时允许多个用户同时访问数据库（数据并发）。</p>
<p>事务是一组构成逻辑工作单元的一个或多个SQL语句。事务以提交或回滚结束，具体取决于数据一致性或数据并发性是否存在任何问题。commit语句使由事务中的SQL语句产生的更改永久化，并且rollback语句撤消由事务中的SQL语句导致的所有更改。</p>
<p>锁是一种机制，禁止两个事务同时操作相同的数据。例如，如果该表上存在未提交的事务，则表锁可防止删除表。在某些DBMS中，表锁还会锁定表中的所有行。行锁可防止两个事务修改同一行，或者它阻止一个事务在另一个事务仍在修改它时选择一行。</p>
<p><a name="stored" id="stored"></a></p>
<h3>存储过程</h3>
<p>存储过程是一组可以按名称调用的SQL语句。换句话说，它是可执行代码，一个迷你程序，执行一个特定的任务，可以调用一个可以调用函数或方法的方式。传统上，存储过程是用DBMS特定的编程语言编写的。最新一代的数据库产品允许使用Java编程语言和JDBC API编写存储过程。用Java编程语言编写的存储过程是DBMS之间可移植的字节码。一旦编写了存储过程，就可以使用它并重用它，因为支持存储过程的DBMS将顾名思义将其存储在数据库中。</p>
<p>以下代码是如何使用Java编程语言创建非常简单的存储过程的示例。请注意，存储过程只是一个包含普通JDBC代码的静态Java方法。它接受两个输入参数，并使用它们来更改员工的车号。</p>
<p>如果您此时不理解该示例，请不要担心。下面的代码示例仅用于说明存储过程的外观。您将在下面的教程中学习如何编写此示例中的代码。</p>
<div class="codeblock"><pre>import java.sql。*; public class UpdateCar {public static void UpdateCarNum（int carNo，int empNo）throws SQLException {Connection con = null; PreparedStatement pstmt = null; try {con = DriverManager.getConnection（“jdbc：default：connection”）; pstmt = con.prepareStatement（“UPDATE EMPLOYEES”+“SET CAR_NUMBER =？“+”WHERE EMPLOYEE_NUMBER =？“）; pstmt.setInt（1，carNo）; pstmt.setInt（2，empNo）; pstmt.executeUpdate（）;} finally {if（pstmt！= null）pstmt.close（）; }}}</pre></div>
<p><a name="metadata" id="metadata"></a></p>
<h3>元数据</h3>
<p>数据库存储用户数据，它们还存储有关数据库本身的信息。大多数DBMS都有一组系统表，它们列出数据库中的表，每个表中的列名，主键，外键，存储过程等。每个DBMS都有自己的函数，用于获取有关表布局和数据库功能的信息。JDBC提供了接口<code>DatabaseMetaData</code> ，驱动程序编写者必须实现该接口，以便其方法返回有关为其编写驱动程序的驱动程序和/或DBMS的信息。例如，无论驱动程序是否支持特定功能，大量方法都会返回。此界面为用户和工具提供了获取元数据的标准方法。</p>
<p>通常，编写工具和驱动程序的开发人员最有可能关注元数据。</p>

        </div>
    <div class="NavBit">
        <a href="../index.html">«上一页</a> • <a href="../TOC.html">小道</a> • <a href="architecture.html">下一页»</a>
    </div>
    </div>
   
<hr class="clearfloat">

<div id="Footer">

<p class="footertext">
<a href="http://www.oracle.com/corporate/index.html">关于Oracle</a> | <a href="http://www.oracle.com/us/corporate/contact/index.html">联系我们</a> | <a href="http://www.oracle.com/us/legal/index.html">法律声明</a> | <a href="http://www.oracle.com/us/legal/terms/index.html">使用条款</a> | <a href="http://www.oracle.com/us/legal/privacy/index.html">您的隐私权</a></p>

<p class="footertext"><a href="http://www.oracle.com/pls/topic/lookup?ctx=cpyr&amp;id=en-US">版权所有©1995,2017 Oracle和/或其附属公司。版权所有。</a></p>
       
</div>   
    <div class="PrintHeaders">
        <b>上一页：</b>目录<br><b>下一页：</b> JDBC体系结构</div>
<!-- Start SiteCatalyst code -->
<script type="application/javascript" src="https://www.oracleimg.com/us/assets/metrics/ora_docs.js"></script>
<!-- End SiteCatalyst code --> 
</body>
</html>